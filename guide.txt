=====Phần 4 chapter 3 video 25====

##1 - Chạy chương trình hello world##
	a) Để chạy được một chương trình website trong java spring cần có thêm thư viện web org.springboot.boot (spring-boot-starter-web) khi thêm vào thì vscode sẽ tự động kéo những thư viện này về
	Setup Spring for web = Update file pom.xml:
	Thêm phần này vào thẻ <dependencies/>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	b) tạo một file java cùng cấp với file java mặc định trong main 
	import những thư viện liên quan đến web cần thiết
	org.springframework.web.bind.annotation.GetMapping
	org.springframework.web.bind.annotation.RestController

====Phần 5 chapter 4 Maven & cấu trúc dự án spring boot====

	video 30: cấu trúc folder và file
	src: chứa tất cả code ứng dụng 
	target: thư mục chứa mã code .class đã được dịch sang mã máy từ src để JVM nó hiểu 
		-> ứng dụng web khi chạy thì chạy trên thư mục target này 
	.vscode: thư mục giúp debug ứng dụng java trên vscode (có nhờ cài các extension như spring boot bashboard)
	.mvn: cách chúng ta chạy ứng dụng maven	
	.gitignore: chứa các loại file ko đẩy lên github 
		như chứa thư mục target vì cái này chứa mã dịch các file .class của chính máy mình hợp với máy mình chạy 
		nếu chạy trên MacOs hoặc thiết bị khác thì mã dịch trong các file .class sẽ khác 
		-> không nên đưa lên github
	file mvnw (để chạy trên MacOS) , file mvnw.cmd (để chạy trên window): là nơi chứa cách cấu hình, chạy dự án nhờ có 2 file này cấu hình mới dịch được từ các file code (src/) sang file mã máy (target/)
		đây là 2 file maven có thể build được dự án = câu lệnh: ./mvnw spring-boot:run 
		(thêm variable enviroment: JAVA_HOME value: C:\Program Files\Java\jdk-17)
	file pom.xml: chứa các cấu hình (dự án) thư viện, cách build dự án ~ packet.json (nếu code NodeJS) 	
	Readme.MD: nơi ghi thông tin về dự án 

	Ngoài ra: 
	JRE system library[JavaSE-17]: chứa all library mà java cài đặt sẵn khi cài đặt java version 17
	Maven dependencies: chứa những thư viện mà file pom.xml cài đặt vào (tức là khi cấu hình 1 library vào file pom.xml thì library này sẽ được tự động down về folder này)

	** những thư mục chứa dấu chấm phía tước chỉ là môi trường giúp chạy code (hạn chế chỉnh sửa)

	video 30: maven ~ gradle-groovy ~ gradle-kotlin
	maven là 1 dự án của apache mục đích sử dụng maven: 
		+ làm cho quá trình build nhanh hơn 
		(ví dụ: để tạo ra target ta chỉ cần viết file code và cấu hình còn lại maven sẽ giúp quá trình tạo)
		+ thống nhất 1 tiêu chuẩn khi build 
		(ví dụ: dùng pom.xml để thêm các dependecies 

	
	video 33: File POM (Project Object Model) ~ packet.json(NodeJs)
	với dự án spring khi khởi tạo sẽ có sẵn file POM
	tiền tố .xml là cú pháp gõ code ~ html
	dùng để quản lý dự án: (compile&build&run)
		+ <groupId/>: tên miền web ghi ngược 
		+ <artifactId/>: tên ứng dụng
		+ <version/>: version phát triển phần mềm
		...
		Những cái này được quản lý thông qua Maven để đảm bảo mỗi thư viện cài đặt vào nó phải có tên của nó 
		ví dụ: cùng 1 <groupId>org.springframework.boot</> nhưng có 2 <artifactId/> chính là 2 service

====Phần 6 - chapter 5 spring and inversion of control====
	Làm được 3 phần: 
		**Trong 1 ứng dụng thì có nhiều component được quản lý bởi Core Container 
		web: học về web
		data access: học về ORM 
		Core container: spring boot đã hỗ trợ
		- Beans: là một thực thể được tạo ra từ class của chúng t hoặc những class mặc định và những Beans này được quản lý bởi Core Container (mỗi class chúng t tạo ra đó là 1 Beans có kí hiệu giống hạt cafe bên trái code) -> tối ưu hóa
		
		Component: là cách chúng ta hiểu cách quản lý code như là 1 dự án thì bao gồm nhiều component trong mỗi component nó sẽ chứa các Beans mà Beans là đại diện cho các class của chúng ta viết 
		@Bean
		@Component: là cách hiểu làm sao chúng ta code và giao tiếp với Java Spring
		**Cách thức để spring có thể quét từ các file class thành các Beans để Container quản lý 
			Thường nó sẽ quét từ file class tạo mặc định khi khởi tạo dự án như LaptopsShopApplication.java trong này nó sẽ có @componentScan (đây là định dạng quét) và nó chỉ quét được những class cùng cấp hoặc những class trong folder cùng cấp với nó các class khác sẽ có @componet cái này giúp class đó đăng ký được quản lý bởi Container 
		@componentScan: giúp nhận dạng Beans và quản lý dự án 
		Quản lý dự án (inversion of control IOC and dependency injection) đây là 1 design pattern
			IOC là cách viết code sao cho hiệu quả và dependency injection là công cụ để thực hiện hóa nó 
			một dự án cần nhiều component -> nhiều class được quản lý bởi Container và những class này có mối quan hệ với nhau ví dụ class A phụ thuộc vào B, C phụ thuộc vào B thì lúc này chúng t chỉ cần làm việc với A và C khi nào dùng B thì IoC này sẽ inject B vào -> tăng tính hiệu quả của design pattern này
			chứ nếu A ban đầu luôn có B và C cũng như vậy khi B thay đổi thì A và C cũng thay đổi theo -> ko hiệu quả 
			Và quan hệ của những class này là Dependency ( tức là class này có sử dụng thuộc tính là class kia chứ ko phải là quan hệ cha con)
			Viết code theo 2 keywords tightly coupled (ràng buộc chặt chẽ vào nhau) và loosely coupled(nơi lõng nhau ra) nên làm loosely coupled để các class hạn chế phụ thuộc vào nhau 
Ví dụ về tightly coupled ở đây trong constructor của Car khởi tạo mặc định 1 engine -> car phụ thuộc chặt chẽ vào engine nếu muốn thay đổi engine ở car phải thay đổi cả class engine
// Class Engine
class Engine {
    public void start() {
        System.out.println("Engine started.");
    }
}

// Class Car
class Car {
    private Engine engine;

    public Car() {
        engine = new Engine(); // Car trực tiếp khởi tạo Engine
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving.");
    }
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.drive();
    }
}


Ví dụ về loosely coupled: ở đây car ko phụ thuộc trực tiếp vào engine nữa và có thể linh hoạt thay đổi engine theo cách ta muốn dependency injection cũng được thể hiện ở đây chúng t chỉ khởi tạo ra engine mà ko gán giá trị cho nó khi nào cần chúng ta mới inject nó vào (gán giá trị) 
// Interface Engine
interface Engine {
    void start();
}

// Class PetrolEngine
class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol engine started.");
    }
}

// Class DieselEngine
class DieselEngine implements Engine {
    public void start() {
        System.out.println("Diesel engine started.");
    }
}

// Class Car
class Car {
    private Engine engine;

    // Dependency Injection qua constructor
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving.");
    }
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Engine petrolEngine = new PetrolEngine();
        Car petrolCar = new Car(petrolEngine);
        petrolCar.drive();

        Engine dieselEngine = new DieselEngine();
        Car dieselCar = new Car(dieselEngine);
        dieselCar.drive();
    }
}
***xem thêm ví dụ về tạo thêm phương thức riêng cho từng class cha để lấy ra giá trị cần để tránh sử dụng trực tiếp giá trị của các element trong class cha -> sự phụ thuộc chặt chẽ 
		Chung quy ở đây muốn injection thì cần phải có injector là chính framework này đã cung cấp hỗ trợ chúng t chỉ có việc code theo format của nó 	

====Phần 7 chapter 6 Spring Security====

##1 - spring boot devtool: hỗ trợ việc chạy restart lại ứng dụng khi sửa code nhanh hơn##

	bình thường chúng ta cần làm 2 bước sửa code lưu code và restart lại ứng dụng 
	tool này sẽ giúp bỏ qua bước restart
	cần cài thêm thư viện này: 
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
	để kiểm tra thư viện đã được kéo về chưa thì chúng ta vào maven -> source -> chọn dependencies 

##2 - @GetMapping: dùng để thiết lập route tạo được link url trong website của chúng ta##

	Dùng để phần quyền người dùng trong security

##3 - database nên dùng SQL vì Java là 1 ngôn ngữ hướng đối tượng ràng buộc chặt chẽ thì SQL là sự lựa chọn hoàn hảo hơn NoSQL##

	javascript - noSQL
	NodeJS - noSQL
	
##4 - setup MySQL Nên dùng docker hơn là cài đặt 1 MySQL về máy cần cài:##

	MySQL Server: nơi lưu trữ
	MySQL WorkBench: nơi view xem thông tin trong database
	MySQL Shell: nơi gõ lệnh
	...

##5 - setup MySQL cho spring boot##

	Thêm 2 dependencies
	<dependeny>
		<groupId>org.springframework.boot</>
		<actifactId>spring-boot-starter-data-jpa</>
	</>
	<dependeny>
		<groupId>mysql</>
		<actifactId>mysql-connector-java</>
	</>

	Trong file pom.xml có <parent></> là org.springframework.boot đây là 1 package lớn những dependency con dependency có <groupId></> là org.springframework.boot sẽ được định nghĩa Version thông qua <parent></> này -> ko cần định nghĩa <version></>
	nhưng ở đây <groupId>Mysql</> ko có parent để cấu hình version này nên phải thêm trực tiếp nó vào
	search maven mysql-connector-java để lấy version mới nhất thêm <version>8.0.33</> vào trong <dependency></> có <groupId>mysql</>
	
	Connect database: 
	Truyền thống thì kết nối thông qua Java Database Connectivity (JDBC)
	hiện tại thì kết nối thông qua file resources/application.properties tất cả các thuộc tính cần làm thì cấu hình ở đây thêm vào 
		spring.jpa.hibernate.ddl-auto=update	
		spring.datasource.url=jdbc://${MYSQL_HOST:localhosts}:3306/laptopshop
			(MYSQL_HOST ở đây là một tham số môi trường lấy tham số mặc định là localhost)
		spring.datasource.username=root
		spring.datasource.password=Thanhtrong@0510
		spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
			(nếu dùng postgresSql thì thể mysql -> postgressql)
		spring.jpa.show-sql: true 
			(cho phép show câu lệnh sql)

##6 - Security##

a) authentication (bạn là ai 'first') & authorization(bạn có thể làm gì 'second'): đọc tài liệu
	ví dụ: 
		authentication: là đăng nhập vào face = tài khoản mật khẩu -> đn vào được xác nhận đc bạn là ai
		authorization: khi đn thành công tức là đã xác thực bạn là ai rồi -> bạn có thể like ảnh người khác, chỉnh sửa comment của chính mình, ko thể xóa bài của người khác .... 
b) nguyên tắc khi làm security: 
	- Trust nothing
	validate every request: luôn xác thực all requests
	luôn xác thực data gửi vào hệ thống 
	- Xác định quyền hạn cho hệ thống: xác định được các actor là ai và quyền hạn của họ 
	- nhiều lớp security: firewall, middleware, ...
	- kiến trúc của security nên đơn giản -> dễ maintain

##7 - setup string security##

	Thêm dependency
	<dependency>
		<groupId>org.springframework.boot</>
		<actifactId>spring-boot-starter.security</>
	</>
	khi thêm vào có thể chương trình chưa đồng bộ với security này thì khi bấm lưu hãy bấm yes ở dưới 
	mặc định khi cài xong: khi vào localhost:8080 || localhost:8080/user || localhost:8080/admin đều redirect chúng ta về localhost:8080/login 
	tự động có 2 trang localhost:8080/login và localhost:8080/logout - username=user, password sẽ hiển thị dưới phần terminal khi chạy lưu ý là password này chỉ có tác dụng trong 1 phiên làm việc (session) khi chạy lại chương trình sẽ có password khác 
	-> mặc định khi cài đặt thành công nó đã tạo ra chức năng bảo vệ ứng dụng của chúng ta
	-> khi chạy thì terminal sẽ hiện lệnh xem logs: 
	mặc định app được bảo vệ bởi DefaultSecurityFilterChain bao gồm nhiều lớp chain/filter xem những filter này ở Tài Liệu
	spring security: 
	một số khái niệm:
		filter chain
		authentication managers
		authentication providers
	Ưu điểm: dễ sửa đổi, mặc định mọi resources của hệ thống đều được bảo về 

##8 - Sơ lược về mô hình spring mvc##

	Bình thường ứng dụng của chúng là là mô hình: 
	Request(thao tác của người dùng) -> server(java, xử lý ) -> response
	thường request sẽ chạy vào controller(HelloWorldController.java) ở đây sẽ xử lý và gửi response lại cho người dùng -> nếu theo mô hình này sẽ không bảo về được ứng dụng 
	-> spring security ra đời thì request nó phải đi qua spring security này trước rồi mới đến controller đấy chính là lý do chưa vào đường link nào của ứng dụng cũng phải login 

	Cách thức hoạt động của spring security: 
	spring security chính là middleware của hệ thống như NodeJs 
	trong mô hình sẽ có các Filter Chain gồm chiều security filter thực hiện từng filter một cách tuyến tính (cái trên chạy xong cái dưới mới chạy) "các lớp phòng thủ" 
	spring security đã viết cho chúng ta sẵn những lớp phòng thủ này -> muốn customize thì chỉnh sửa code vào những lớp đã có sẵn đấy 
	thường 1 request muốn gửi đến server cần thông qua DefaultSecurityFilterChain mặc định của spring security gồm nhiều lớp chain/filter sẽ lọc những request này -> request hợp lệ/ko hợp lệ
	một số filter/chain trong DefaultSecurityFilterChain cần dùng: 
	org.springframework.web.filter.CorsFilter@4c1d59cd: dùng để kết nối frontend và backend
	org.springframework.security.web.csrf.CsrfFilter@318c68d	org.springframework.security.web.authentication.logout.LogoutFilter@4733f6f5
	security.web.authentication.UsernamePasswordAuthenticationFilter@56cc9f29	security.web.authentication.ui.DefaultLoginPageGeneratingFilter@41ccb3b9
	security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@76cf841
	security.web.savedrequest.RequestCacheAwareFilter@f1266c6
	org.springframework.security.web.access.intercept.AuthorizationFilter@415ef4d8: cái này luôn cuối cùng vì đây là bước phân quyền người dùng sau khi đã đăng nhập thành công đã xác thực người dùng đó là ai rồi

====Phần 8 chapter 7 Spring MVC====

	**sửa lỗi tồn đọng
	Format code cho xml trong vscode cài thêm extension xml tools 		
	sửa dependency của mysql <groupId>com.mysql</> <artifactId>spring-boot-starter-j</> (org.springframework.boot version từ 3. trở đi dùng cái này ko cần điền version mà giao cho springboot parent cấp còn dưới 3. dùng <groupId>mysql</> <actifactId>spring-boot-starter-java</>

##1 - Mô hình MVC##

	Viết code theo mô hình MVC: Model - View - Controller:
	View: chịu trách nhiệm render(hiển thị) giao diện website
	Model: các đối tượng sử dụng hệ thống được mô hình hóa qua OOP. Với Spring models bao gồm các tables trong database 
	Controller: chịu trách nhiệm xử lý dữ liệu - giúp tương tác giữa View và Controller (là nơi xử lý logic code)
	Spring FrameWork đã có hỗ trợ mô hình MVC -> ko cần cấu hình thêm
 
##2 - Java Annotation ~ Decorator trong NodeJs##

a) mục đích giúp Decorate 1 class giúp tăng sử hiệu quả của class 
	Mỗi Annotation chỉ có tác dụng đối với A(class, function, element) ngay sau nó
	ví dụ: 
	Annotation @override trước 1 function -> java có thể hiểu đây là 1 function từ child override của parent
	Java Spring các Annotation có thể dùng cho class, function, element kí hiệu '@'
	
	Annotation @SpringBootApplication giúp class chạy đầu tiên khi run ứng dụng có
		@SpringBootConfiguration: config Spring Boot
		@EnableAutoConfiguration: enable phần tự động cấu hình Java
		@ComponentScan: định nghĩa cách thức Scan 
		...
	Khi 1 class chạy thì nó sẽ đọc Annotation -> nó sẽ truyền thêm 1 meta-data để nhận biết loại class theo annotation đó

b) cấu hình lại username, password cho trang login
	cấu hình vào file .properties
	spring.security.user.name=Thanhtrong
	spring.security.user.password=Thanhtrong@0510
	
	**disable tạm thời spring security = cách chỉnh sửa lại Annotation @SpringBootApplication bỏ đi phần security đó
	@SpringBootApplication(exclude = org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class)
	mình dùng exclude để loại bỏ đi 1 phần cái tự động config khi cài đặt Security Spring 
	include <> exclude
	
c) Cấu hình cấu trúc dự án theo chuẩn 
	https://github.com/hoidanit-be-java-spring-mvc/02-java-react-with-jhipster
	cấu hình theo link này 
	thêm các folder: config, service, controller (web nếu dự án lớn trong này sẽ chứa các controller), domain(models/entity), repository, security
	
	xóa HelloWorldController.class

d) Bắt đầu code
	Trái tim của mô hình MVC là controller
-Controller: chỉ để điều hướng 
	(1)Tạo class UserController để biến class này thành controller thì dùng annotation @controller trong class này cần định nghĩa mô hình MVC thêm những Function ứng với từng View 
	public String getHomePage() -> làm sao để truy cập được Phương thức này -> dùng annotaion @RequestMapping giống @Route ở Flask ở đây là gửi 1 yêu cầu lên server(java) gửi từ trình duyệt web 
		Nếu chỉ viết tới đây chạy chương trình truy cập localhost:8080 sẽ lỗi 404 vì đây chưa đủ mô hình MVC chưa tìm thấy các file tĩnh như html, css, js, images  
		-> thêm vào folder Service
	(2) Viết code dùng Pattern dependency Injection trong class UserController tạo 1 element	
		private UserService; 
		dùng hàm tạo để khởi tạo giá trị cho UserService	
		và ở hàm getHomePage() return userService.HandleGetHomePage() 
		Từ đây đã ra được mô hình MC: từ models -> controller nhưng chưa có View -> vẫn chưa hiển thị được 
			** tất nhiên models ở đây sau này sẽ là domain nhưng hiện tại chỉ test 
	(3) chuyển @Controller -> @RestController để có thể hiển thị ra màn hình dùng mô hình Restful API, chuyển @RequestMapping -> @GetMapping
		

-Service: 
	(1)Tạo class UserService thêm Annotation cho class này @Service tạo 1 function HandleGetHomePage()
		
Render view HTML 
File Tĩnh là các file ít thay đổi thường sẽ public như file html, css, javascript, images

##4 - Quay lại mô hình MVC bỏ đi Rest API##

	- sử dụng lại @Controller 
	- Tạo View (view là file static html để hiển thị ra màn hình)
		tạo thư mục src/main/resources/static/hello.html
	- quay lại UserController.GetHomePage cho nó return về tên của file html hello.html
	-> Controller điều hướng tới file tĩnh -> đã có view hiển thị được ra màn hình
	** đối với spring tất cả các file đặt trong static nó sẽ hiểu là những file được public ra ngoài internet thông thường là View 
	-> vẫn còn thiếu models những nếu dùng các file tĩnh như ngày thì rất khó để generate ra được data động tức là khó lấy dữ liệu từ models rồi dùng controller điều hướng đến view được 
	-> cần sử dụng View Engine 
	**@RequestMapping(đường link url / chính là localhost:8080)
	**cần trả về String vì java ko hiểu đâu là file của chúng ta -> ta phải đưa tên file cho nó -> cần return về String

##5 - dùng view engine cách truyền data từ models - controller - điều hướng dữ liệu đó đến view để hiển thị##

	view engine là công cụ giúp code html ít đi - giải quyết được bài toán tạo ra nội dung động cho chúng ta = cách viết code java trực tiếp vào file html = Spring View Technologies trong nhóm này chúng ta dùng JSP (Java Server Pages) là một View Engine ~ EJS(NodeJs), Blade(Lavarle) sau này nên tìm hiểu về Thymeleaf

##6 - Setup JSP##

	thêm các thư viện
	<dependency>
	    <groupId>org.apache.tomcat.embed</groupId>
	    <artifactId>tomcat-embed-jasper</artifactId>
	</dependency>

	<dependency>
	    <groupId>jakarta.servlet.jsp.jstl</groupId>
	    <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
	</dependency>

	<dependency>
	    <groupId>org.glassfish.web</groupId>
	    <artifactId>jakarta.servlet.jsp.jstl</artifactId>
	</dependency>

	**Thường những cache được lưu vào thư mục ../.m2/
##7 - Cấu hình JSP có 2 cách: khi cấu hình ở đây nó sẽ chỉ tự động load những file view được cấu hình sẽ ko load file tĩnh mặc định nữa##

cách 1: cấu hình trực tiếp vào .properties
	spring.mvc.view.prefix=/WEB-INF/view/ 
	spring.mvc.view.suffix=.jsp
	**mvc.view là chúng ta dùng theo mô hình mvc
	**prefix là nơi cấu hình thư mục mà chúng ta muốn quét để tìm các file hiển thị ra view 
	**suffix là nơi cấu hình extension của các file cần tìm trong prefix -> khi return ở controller chỉ cần return tên file ko cần return extension
	Tạo thêm 1 folder webapp ở trong main cùng cấp với folder resources để chứa /WEB-INF/view/:
		- Trong resources/static: sẽ chứa các file tỉnh 
		- các file render động sẽ lưu trong webapp/WEB-INF/view/ là những file động ko cho public 

cách 2: cấu hình thông qua code đặt trong config/WebMvcConfig.java theo format 
@Configuration
@EnableWebMvc
public class WebMvcConfig implements WebMvcConfigurer {

  @Bean
  public ViewResolver viewResolver() {
    final InternalResourceViewResolver bean = new InternalResourceViewResolver();
    bean.setViewClass(JstlView.class);
    bean.setPrefix("/WEB-INF/view/");
    bean.setSuffix(".jsp");
    return bean;
  }

  @Override
  public void configureViewResolvers(ViewResolverRegistry registry) {
    registry.viewResolver(viewResolver());
  }
}

**Nhờ có @EnableWebMvc -> Spring nhận biết được chúng ta muốn cấu hình MVC
	 @Configuration: config này dùng để viết @Bean này giúp class này tối ưu để container quản lý 
**Đặt trong thư mục config theo mô hình của project trong github
**Nên dùng code vì đối với Spring Security sẽ ko có .properties cho chúng ta cấu hình 	

##8 - Truyền từ Controller vào view = JSP có 3 cách khi dùng framework##

	Model(đơn giản nhất)
	ModelMap(tương tác với connection, array, ...)
	ModelAndView(return cả view cả data trong 1 lời gọi)
Dùng model:
	trong controller/UserController/getHomePage truyền vào tham số (Model model)
	**Model ở đây là Spring framework đã có sẵn và mình dùng mô hình MVC nên nó mới hiểu được
	Nội dung hàm mình sẽ thêm thuộc tính cho model
	model.addAttribute() 
	**đây là thêm 1 object trong javascript gồm key là tên dùng để truy cập và value 
	@RequestMapping("")
    	public String getHomaPage(Model model) {
        String test = this.userService.handleGetHomePage();// lấy dữ liệu từ database
        model.addAttribute("test", test);
        String SinhVien = "Thanh Trong";
        model.addAttribute("TenSinhVien", SinhVien);
	**sau khi controller xử lý xong dữ liệu
        return "hellofromjsp";//trả về cho view 
    }

**ở đây xem như this.userService.handleGetHomePage() là database chúng ta lấy dữ liệu về controller qua biết test
khi chúng ta sử dụng MVC spring sẽ nhận biết được Model chúng t sẽ dùng nó sẽ controller xử lý dữ liệu để gửi cho view = cách model.addAttribute(name, value). name, value ở đây là 1 object theo javascript
khi return hellofromjsp thì trong file JSP này đã có những dữ liệu từ controller gửi lên là được truy cập thông qua ${name} được truyền lên 
a) cú pháp của JSP
	khi in ra 1 biến được gửi lên từ controller ở trong file jsp ${name}
b) JSPL (JSP Standard Tag Library) là phần mở rộng của JSP 
	khi in ra 1 biến được gửi lên từ controller ở trong file jsp <c:out value="${name}"/> c: ở đây tượng trưng cho thư viện core 
	nên dùng cái này khi dùng loop, ... giúp tăng hiệu năng 
	<%@page contentType="text/html" pageEncoding="UTF-8"%> 
	<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
	**<%@page/> set file của chúng ta là dạng text/html
	<%@ taglib> là để chúng ta cấu hình chúng ta dùng thư viện nào ở đây là http://java.sun.com/jsp/jstl/ và prefix="c" là tiền tố 'c' thể hiện chúng ta dùng /core 


##9 Tích hợp bootstrap và JQuery import vào chính file .jsp##

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

***khi cấu hình JSP thì chúng ta chỉ cho nó load các file JSP trong webapp -> nó sẽ ko load các file tĩnh trong /resources/static như mặc định nữa -> xóa thư mục static 
thêm vào thư mục /webapp/resources đây sẽ là nơi chứa website app của chúng ta như css/, js/, images/, ...

***cấu hình thêm để tối ưu các đường dẫn khi dùng thẻ link trong file JSP để link tới css, js ....
@Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/css/**").addResourceLocations("/resources/css/");
    }
đầu tiền /resources/css sẽ luôn được link tới nếu t điền bất kì url nào = /css/....
/css/**: 2 dấu ** ở đây thể hiện nó sẽ truy cập tất cả folder/file trong thư mục /css/

##10 Tạo trang http://localhost:8080/admin/user là trang tạo user Create.jsp##

	Trong /webapp/WEB-INF/view tạo /admin/user trong này tạo 1 file Create.jsp tạo ra giao diện = bootstrap
	<div class="container mt-5"> 				
		<div class="row"> 
			<div class="col-md-6 col-12 mx-auto" >
				<hr>
				<form></form>
			</div>
		</div>
	</div>
	
	** class=container mt-5 thì container sẽ giúp tạo khoảng cách 2 bên (margin left, right để form ko sát với ngoài biên) mt-5 là margin top 5 đơn vị = 3em theo quy định của bootstrap (1-5 đơn vị)
	   class=row sẽ đi kèm với container bù trừ với nó 
	   Trong bootstrap (dùng grid) chia màn hình máy tính thành 12 phần (12 columns)
	   -> class="col-md-6 col-12 mx-auto" đối col-6 tức là lấy 1/2 màn hình thêm -md là để hiển thị trên laptop, col-12 hiển thị trên điện thoại sẽ là full màn hình, mx-auto thì x ở đây chính là left và right mx là margin left, right auto thì nó sẽ tự động căn giữa màn hình 
	
	Trong controller tạo 1 class có @RequestMapping("/admin/user") và return về "/admin/user/Create.jsp" ở đây chúng ta đã cấu hình mặc định sẽ tìm trong folder /WEB-INF/view nên chỉ cần điền url đối với view

##11 gửi data với HTML Form##

	@RequestMapping() mặc định khi sử dụng ko điền method cho nó thì sẽ là GET lấy data nếu muốn truyền data từ client lên server thì ta dùng method POST
	@RequestMapping(value="url", RequestMethod.POST) thêm 1 class như này làm controller nhận request khi submit từ form

	thêm <%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%> vào file JSP đây là thư việc của JSPL để làm việc với form 
	khi thêm thư viện thì thêm form: vào trong các thẻ trong <form:form></form> có hỗ trợ thêm thuộc tính path để thay thế cho id 
	để có thể cho controller biết thuộc tính đã có path là của form nào thì chúng ta dùng annotation modelAttribute="name" name này sẽ đại diện là 1 object gửi đi những cái path đặt trước đó là element của name này 
	modelAttribute dùng ở 2 nơi 1 là @modelAttribute annotation ở controller để xử lý dữ liệu 
				    2 là truyền trực tiếp vào form để chỉ định những modelAttribute phải có tên khác nhau và chỉ dùng được khi sử dụng <form:form> của thư viện <%@taglib uri="http://www.springframework.org/tags/form" prefix="form" %> đã được import vào
	khi chúng ta dùng trực tiếp trong form thì cần phải có 1 biến là chính cái name ở controller ở class có method GET link cái JSP chứa cái form đó nếu ko khi chạy sẽ hiện lỗi 500 Việc thêm thuộc tính  
		model.addAttribute("newUser", new User()); //đặt trong function của class GET biến này sẽ gửi lên view file JSP làm value của modelAttribute value này sẽ là 1 object ở view sẽ lấy dữ liệu nhập vào từ form rồi gửi về controller nhận ở function FOST để xử lý 
		**Lưu ý những thuộc tính trong newUser phải có trong class User và ko được sai tên nếu ko sẽ bị lỗi mặc dù là hàm khởi tạo không tham số (path của newUser phải trùng với những element trong class User)	
		
	
	Để nhận và xử lý dữ liệu thì thêm @modelAttribute trong tham số của hàm ở class POST trong controller 
	@RequestMapping(value = "/admin/user/createuser", method = RequestMethod.POST)
    	public String CreateUser(Model model, @ModelAttribute("name") User trongNguyen) {
        System.out.println("run here" + trongNguyen.toString());
        return "hellofromjsp";
    }
	với @ModelAttribute("name") là lấy modelAttribute nào trong JSP
	    User là kiểu dữ liệu 
	    trongNguyen tên biến 
	từ đây chúng ta đã nhận được dữ liệu từ view gửi về controller 

**Lưu ý: 
ở GetMapping khi dùng Model đưa 1 object lên view = model.addAttribute() -> nó chỉ thực hiển việc đưa Object này lên và có thể dùng Object này thông qua ${} 

nếu có thiết lập ModelAttribute ở form thì phải đặt tên giống với tên được Model đưa lên còn lại toàn bộ dữ liệu trong Object này khi truyền về Post sẽ được quyết định bởi Form: những thuộc tính của Object này lấy giá trị bởi các thuộc tính path trong các tag input ở những tag này vẫn có thể sử dụng dữ liệu Object được đưa lên qua ${} -> phải gán hoặc chỉnh sửa dữ liệu cho các path này nếu các path này ko có dữ liệu -> thì nó sẽ gửi về POST giá trị null/0 đối với path đó của Object được định nghĩa bởi ModelAttribute ko liên quan tới Object được Get gửi lên 

====Phần 9 chapter 8: Spring Data với JPA và hibernate====

1 - Spring cung cấp Spring data là công cụ giúp chúng ta tương tác với database một cách đơn giản 
	- Trong này nó sẽ cung cấp 1 đối tượng Repository nhờ đối tượng này chúng ta ko cần viết câu lệnh SQL nhưng vẫn truy vấn vào database được 
	- chúng ta sẽ sử dụng 1 model JPA trong Spring Data 

##2 - Cài đặt thư viện JPA##
	<dependency>
		<groupId>org.springframework.boot</>
		<actifactId>spring-boot-starter-data-jpa</>
	</>
	**khi cài công cụ có chữ start mô hình chung nó đã cài đủ những công cụ cần thiết //ở đây nó đã cài sẵn hibernate

##3 - tương tác với SQL có 2 cách:##

	- Sử dụng JDBC: Java Database Connectivity 
	đây là cách chúng ta kiểm soát database thông qua các câu lệnh truy vấn như select, update, insert, ...
	hoạt động: Tạo 1 kết nối tới database -> thông qa đó dùng câu lệnh truy vấn 
	- Sử dụng ORM(SQL) / ODM (NoSQL):
	ORM = Object Relational Mapping
	ODM = Object data/document Mapping
	đây là cách chúng ta sử dụng database thông qua 1 object/đối tượng -> ko cần viết câu lệnh SQL 
	Ưu điểm: là cú pháp dùng chung cho nhiều loại SQL chứ nếu dùng JDBC thì mỗi loại lại có mỗi loại truy vấn khác nhau
	Nhược điểm: Hiệu năng giảm hơn so với viết câu lệnh truy vấn thông qua dùng JDBC

##4 - Sử dụng Hibernate để dùng ORM thao tác với database##

Mô hình: 
	Spring <->Spring data JPA <-> JPA <-> Hibernate <-> database 
	chúng ta đang dùng spring để làm ứng dụng và muốn connect tới database thì cần Spring data và ở đây chúng ta dùng Spring data JPA cái này nó lại dựa trên JPA (Java Persistence API: là 1 API mà Java cung cấp) -> ở đây chúng ta đã có thể connect tới database nhưng đôi khi sử dụng API của Java để tương tác với database khá dài dòng, ... -> công cụ/framework Hibernate (chứa JDBC) ra đời được kế thừa và phát triển thêm từ JPA 
	hibernate giúp chúng ta viết ORM và nó sử dụng JPA để thao tác với data

##5 - Debug java với VScode là debug phía backend##

	không cần cài thêm công cụ gì khác 
	đối với vscode có 1 thư mục .vscode là nơi lưu cấu hình của việc debug để chạy được chế độ debug chúng ta có file launch.json đây là vscode tự động sinh khi sử dụng extension bashboard nếu ko có file này sẽ ko chạy được chế độ debug 
	hoạt động: bấm vào bashboard chọn dự án chọn debug - terminal sẽ xuất hiện chữ debug thay vì chữ run 
		   dùng breakpoint để dừng tại dòng để kiểm tra giá trị 
	
##6 - Entity (trong ứng dụng đặt là domain)##

	entity là thực thể ~ actor là những tác nhân tham gia vào hệ thống 
	bản chất entity là 1 class của Java đại diện cho 1 table trong database
	-> entity là models trong mô hình MVC
	Để tạo 1 đối tượng xoay quanh Object và ko cần dùng câu lệnh truy vấn -> chúng ta sẽ viết hoạt động của 1 đối tượng để tạo 1 database chứ ko viết câu lệnh truy vấn thông thường mà chúng ta sẽ mô hình hóa nó lên 	
	
	Để 1 cái trở thành 1 entity -> dùng annotation @Entity phải import nó phải liên quan đến JPA (Java/javax/jakarta persistence API)  entity là 1 trong những API của JPA 	
	khi dùng @Entity vào 1 class -> trong class này phải sử dụng thêm Annotation @Id để xác nhận 1 entity(table) đã có 1 ID (primary key) (@GeneratedValue(strategy = GenerationType.IDENTITY số tự tăng)
	-> sau khi cấu hình xong chạy chương trình chỉ = thêm 2 annotation && đã kết nối với database cấu hình ở .properties thì nó đã tự động tạo table theo định dạng của entity đó 
	**tên biến trong java fullName -> table: full_name vì trong database ko phân biệt chữ hoa chữ thường 

##7 - Mô hình MVC kết hợp với Spring Data##

** đặt tên models là domain chứ ko phải entity/model vì dựa theo base của jhipster ở đây nó đặt là domain là dựa trên 1 design pattern gọi là domain-driven design (domain ở đây sẽ quyết định hướng thiết kế của dự án vì trước khi viết view hoặc controller trc hết t phải tạo ra 1 domain cho cái đó như xác định dự án có bao nhiêu thực thể/actor và nó có thuộc tính gì -> mọi thứ phải xuất phát từ domain)

**Repository Pattern (là công cụ kết nối tới database)
Mô hình này gồm 3 lớp để kết nối đến database 
	Lớp 1: Domain Model Layer (lớp model/domain) @Entity
	Lớp 2: Infrastructure-Persistence Layer(Repository) @Repository 
	Lớp 3: Data tier(lớp data cho phép kết nối tới các bảng trong database)

	**tới đây ta đang hoàn thành Lớp 1 và Lớp 3 (đã có model trong domain và có các Annotation kết nối với db) đã có thể kết nối và sử dụng được database nhưng khả năng mở rộng và bảo trì kém -> tạo ra mô hình Repository Pattern -> chia nhỏ bớt các chức năng ra (giống microservices) để dễ nâng cấp bảo trì 
 -> muốn theo mô hình này phải viết thêm 1 lớp repository lớp này chỉ làm 1 việc kết nối xuống database còn models sẽ chỉ dùng để định danh repository sẽ dùng những định danh này 

Thực hiện tạo 1 user cho database thông qua form dùng Repository Pattern (domain, repository,sql) && Sử dụng Service && Viết code theo dependency injection 
- tạo repository/UserRepository.java để biến nó thành repository -> dùng annotation @Repository ở đây chúng ta sẽ ko định nghĩa ra 1 class mà là 1 Interface (java spring muốn giấu đi quá trình xử lý chỉ show ra muốn làm gì và làm ntn thì java spring nó đã làm sẵn) với nội dung 	
	
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    User save(User user);
}

- cấu hình lại controller viết code theo dependency injection
// final theo chuẩn dependency injection (ko thay đổi giá trị sau khi khởi tạo)
    private final UserService userService;
    private final UserRepository userRepository;

    public UserController(UserService userService, UserRepository userRepository) {
        this.userService = userService;
        this.userRepository = userRepository;
    }

//chỉnh lại chỗ method POST khi nhận dữ liệu từ view submit 
@RequestMapping(value = "/admin/user/createuser", method = RequestMethod.POST)
    public String CreateUser(Model model, @ModelAttribute("newUser") User newUser) {
        this.userRepository.save(newUser);
} 
ở đây chưa hiểu=)) là interface UserRepository sao tạo được đối tượng ??? và abstract function save() ko có nội dung nhưng vẫn hoạt động=)) lưu 1 user truyền vào xuống database hàm save tự biết được nếu id=0/null thì nó sẽ hiểu là tạo đối tượng mới và dùng identity để tăng giá trị cho Id 

=== đoạn code sửa trong method POST là chưa phải mô hình hoàn chỉnh vì chúng ta đang sử dụng trực tiếp method của repository để chạy -> phải dùng service tạo 1 mô hình hoàn chỉnh tạo 1 class trong service tạo method xử lý add người dùng và dùng repository trong này -> trong controller t chỉ cần gọi method tường minh từ service ===

Sửa trong Service 
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User handleSaveUser(User user) {
        return this.userRepository.save(user);
    }

Sửa lại method POST trong controller
@RequestMapping(value = "/admin/user/createuser", method = RequestMethod.POST)
    public String CreateUser(Model model, @ModelAttribute("newUser") User user) {
        this.userService.handleSaveUser(user);
}

##8 - Định nghĩa Repository Query##
Java Spring có cung cấp công cụ để tối ưu việc xây dựng nên các câu lệnh Query Gồm 3 bước: 
Bước 1: Tự định nghĩa tên của Method theo quy tắc 
Bước 2: Spring sẽ tự động chuyển "tên method" thành câu lệnh truy vấn database
Bước 3: nhận kết quả ra từ Repository

**tìm hiểu về keywords, mệnh đề quan hệ/điều kiện (And, Or, Before, After, Exist...) và method
https://docs.spring.io/spring-data/jpa/reference/repositories/query-keywords-reference.html
https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html
Nhờ Bước 2 mà chúng ta có thể trả lời câu hỏi tại sao chỉ định nghĩa 1 abstract method nhưng khi chạy chương trình ứng dụng vẫn có thể kết nối xuống database (từ tên method được đặt theo quy tắc của Java Spring - Java Sping convert nó thành câu lệnh truy vấn xuống SQL) 

Để xem cách chuyển từ tên method -> câu lệnh truy vấn SQL thì cấu hình thêm trong file .properties 

Tạo Repository Query:
	khi ta dùng biến UserRepository có rất nhiều method được cung cấp mà chúng ta chưa định nghĩa là nhớ kế thừa CrudRepository trong lớp này Spring đã viết sẵn cho chúng ta. Nhưng nên chúng ta muốn viết method riêng -> tự định nghĩa câu lệnh Query 
	-> chung quy lại có thể tự định nghĩa ra Repository bất cứ ở đâu miễn là dùng class của @Repository
	**Tạo 1 abstract List<User> FindAll() trong Repository -> dùng ở Service -> lỗi 
	**Dùng trực tiếp FindAll() ở Service ko cần tạo trước List<User> FindAll() trong Repository -> ko lỗi
	** Những cái như FindByEmail, FindByEmailAndAddress -> thì có thể dùng ở Repository sau đó mới dùng qua service những cái này nó đã gởi ý sẵn cho ta bởi vì khi kế thừa JpaRepository<User, Long> ta có truyền User vào Spring sẽ vào đó và đọc những thuộc tính của ta đễ gợi ý 
	**Lưu ý: ta có Find...By ở đây ko có sự khác biệt bởi FindOneBy, FindBy, FindAllBy khi viết trong Spring còn để Spring phân biệt chúng thì nó sẽ dựa vào kiểu dữ liệu trả về là 1 object hay 1 List. mặc định những hàm này sẽ trả về List -> chung ta phải giới hạn phần tử trả về + phải kết hợp thêm điều kiện (như tìm cái đầu tiên) như dùng FindFirst lấy phần tử đầu tiên || FindTop1 (Top + number ở đây là số phần tử bị giới hạn)
Để chính quy bài bảng thì những Repository nên đặt ở Repository (abstract method) và sử dụng nó tường minh ở Service
	Nên đổi từ CrudRepository -> JpaRepository bởi vì đa số method cần thiết trong CrudRepository lại return ra Iterable khá khó sử dụng còn JpaRepository sẽ trả về List 

##9 - hoàn thành page /admin/user##
a) Load được tất cả dữ liệu của các user hiển thị lên page 
	- lấy dữ liệu -> gửi lên view -> dùng foreach để render ra dữ liệu
b) Sửa lại trang /admin/user/create khi bấm submit thì quay lại trang /admin/user
	theo tư duy thông thường thì chỗ return của function khi bấm submit sẽ redirect tới đơn giản ta chỉ cần chỉnh lại file .jsp của /admin/user -> nhưng đây chỉ hiển thị ra view và sẽ ko có data vì thực chất url nó sai và ko thể chạy được các câu lệnh load data lên như ban đầu 
	-> dùng redirect:url cần redirect tới lúc này khi return nó sẽ redirect tới cái function của cái url đó -> hoạt động của ứng dụng sẽ đúng

c) Tạo ra trang view detail khi bấm vào view của từng user sẽ hiện thông tin đầy đủ của họ 
	- phải lấy được Id của user được bấm vào nút view của từng người dùng 
		c1: dùng 1 form bao quanh những button đó sau khi submit sẽ xử lý - tuy nhiên ở đây dùng form tức là chúng ta gửi dữ liệu lên server - nhưng mà ở đây ta đơn giản chỉ truy vấn và xem dữ liệu của người dùng ko gửi bất cứ dữ liệu gì -> ko nên sử dụng cách này
		c2: dùng thẻ a và href và lúc render ra dữ liệu của từng user chỗ href ta sẽ chèn luôn user.id vào href="/admin/user/${user.id}" đây cũng sẽ là url ta xử lý dưới controller và ta sẽ lấy id đó ở controller = Annotation @pathVariable 
	
	
##10 - Tổng kết về mô hình MVC##
a) các thành phần tham gia 
	M: code trong thư mục Domain(theo domain-driven design nên ko đặt tên là entity hay models) models chịu trách nhiệm quản lý các "đối tượng/tác nhân" tham gia vào hệ thống, chính là các tables lưu trữ trong database (nhờ Annotation hỗ trợ của Spring mà có thể biến class thành các entity/tables) 
	V: code trong thư mục /webapp/WEB-INF/viewlà các file .jsp (html), tạo ra giao diện cho người dùng nhìn thấy
	C: code trong thư mục controller giúp điều hướng các yêu cầu của người dùng và cung cấp lại kết quả cho người dùng 
b) mối quan hệ giữa các thành phần 

url:../Users -> Controller <-> Services <-> Repository <-> database 
		    |
		   JSP (view)	
- khi người dùng gõ 1 đường link vào URL -> gửi 1 request lên server (java) "server sẽ quét qua tất cả controller để xem controller nào phụ trách nhận và xử lý request đó (1 function của controller)"
	+ nếu không cần lấy data -> controller trả về view - view render ra giao diện cho khách hàng thấy kết quả 
	+ nếu cần lấy data:
		controller sẽ gọi tới services (services là nơi chia nhỏ công việc từ controller) ở services sẽ ko kết nối trực tiếp tới database mà ở đây chúng ta dùng Repository pattern 
		services sẽ thông qua Repository để kết nối tới database (tách ra như này để chỉ có 1 lớp duy nhất kết nối trực tiếp tới database là repository -> dễ điều chỉnh và bảo trì)
		....
		sau khi lấy được data:
			repo trả về services
			services trả về controller
			controller ném data cho view 
			view sẽ render ra giao diện để người dùng thấy kết quả 

	
##11 - hoàn thành chức năng update, delete##
	Hàm save() -> java spring đã làm cho chúng ta nếu đã có user được save vào nếu đã có thông tin -> update 
										      chưa có -> create
	

====Phần 10 chapter 9 Project Thực Hành===

##1 - Nhìn lại kiến thức đã học:##
a) công nghệ đã dùng: 
	- sử dụng Spring boot để chạy dự án: 
		chính là @Annotation @SpringBootApplication trong class LaptopShopApplication.java 
		Nhờ Annotation này mà giúp chạy dự án - khởi tạo spring context, container - nạp và quản lý tất cả Beans 

		file .properties trong /resources giúp cấu hình dự án 

	- Sử dụng Spring MVC để thực hiện mô hình MVC: bên tron spring framework đã chứa sẵn Spring MVC 
		+ Model(entity)
		+ View(jsp)
		+ controller 
		**Hầu hết các Annotation để cấu hình MVC đã có trong springframework -> import vào sử dụng 

	- Spring Data(Hibernate/JPA) để mô hình hóa Model và kết nối với database: 
		+ Domain-driven design 	
		+ Repository pattern

b) Để phát triển dự án
	- Định nghĩa thêm Model(Spring data)
	- Viết logic theo mô hình MVC(Spring MVC)
	
##2 - Phân tích Yêu cầu thực hành##

Ý tưởng: có một trang web để hiển thị sản phẩm cho người dùng lựa chọn, các chức năng chính như sau: 
	- Hiển thị danh sách sản phẩm (home page)
	- xem chi tiết từng sản phẩm khi bấm vào 
	- Tìm kiếm sản phẩm theo tiêu chí nào đó 
	- Giỏ hàng
	- Mua hàng
	- ...
	Link tham khảo: https://fptshop.com.vn/may-tinh-xach-tay

3- Phân tích Models của bài toán 

Phân tích hệ thống cáo bao nhiêu người dùng - bao nhiêu actor 

Có 2 loại chính: 
- Người dùng chưa đăng nhập (guest) 
	Có thể: 
		Xem danh sách sản phẩm, xem chi tiết sản phẩm
		Tìm kiếm sản phẩm theo tiêu chí 
	Không thể: 
		Đặt hàng (vì cần thông tin người dùng)
		Thêm/sửa/xóa sản phẩm hoặc thông tin trên website 

- Người dùng đã đăng nhập (user)
Phân chia theo vai trò của người dùng 
	Vai trò của người dùng thông thường (user)
		Kế thừa lại tính năng của guest
		Có thể đặt hàng 
		Không có quyền Thêm/sửa/xóa sản phẩm hoặc thông tin trên website 
	
	Vai trò người dùng quản trị (admin)
		Kế thừa lại tính năng của user
		Full quyền trong hệ thống 

##4 - Phân tích thiết kế database##
Bước 1: Xác định các đối tượng tham gia vào hệ thống 
	Users		Roles(Vai trò của người dùng)		Products		Orders
"Chuẩn hóa dữ liệu: 1NF, 2NF, 3NF"
Bước 2: Xác định quan hệ giữa 
	Roles - User: 1 - N
	Order - Product: N - N
	Order - User: N - 1
	**Ở đây người dùng ko liên quan đến sản phẩm mà chỉ liên quan đến đơn đặt hàng 

**Associations: chia làm 2 hình thức
	+ Unidirectional(unique): quan hệ một chiều -----> là quan hệ giữa 2 table chỉ có 1 phía
	+ Bi-Directional: quan hệ 2 chiều ------ ràng buộc qua lại giữa 2 thực thể 
	Khi nói về 2 loại quan hệ này có thêm 2 keywords:
		The owning side: Bên sở hữu bên có foreign key
		Inverse side: bên ngược lại ko nắm cái gì cả (nơi sử dụng mappedBy)

	VD: Person =(1)<------ (0-1 onetoone)author
 	    Publisher(onetomany) (1)<------ (n manytoone)book	
	-> quan hệ 1 chiều ghi loại quan hệ ở 1 phía
	-> quan hệ nhiều 2 chiều ghi loại quan hệ 2 phía 
	Khi đọc mối quan hệ (đưa tên của bảng vào phía trước 1 mối quan hệ và đọc từ trái sang publisher one to many -> một nhà xuất bản thì có nhiều sách, book many to one nhiều sách được sx bởi 1 nhà xuất bản 
Tham khảo: https://docs.jboss.org/hibernate/orm/6.4/introduction/html_single/Hibernate_Introduction.html#associations

##5 - Các loại quan hệ vs code##
a) quan hệ one to many - many to one
Chúng ta có các Annotation:
	@ManyToOne(para)
	@OneToMany(para)
para: fetch=LAZY/EAGER(hăng hái) thiết lập khi chúng ta quan tâm đến hiệu năng 
	LAZY loading: khi nào cần tài nguyên chúng ta mới load nó lên -> hiệu năng cao 
	EAGER loading: ngay từ đầu đã load full tài nguyên -> hiệu năng ko cao

Ví dụ: Publisher(onetomany) (1)<------ (n manytoone)book
	Class Book {
		@ManyToOne(fetch=LAZY)
		Publisher publisher;
		//ở đây chúng ta dùng đối tượng để biểu thị mối quan hệ 
	}
	chúng ta sẽ không khai báo Long publisherId; ở đây vì theo OOP việc Join giữa 2 table với nhau thì ORM/Hibernate đã giúp chúng ta làm òi 
	
	Class Publisher {
		@OneToMany(mappedBy="publisher")
		Set<Book> books;
	}
	Ở đây chúng ta có thể dùng List nhưng set hiệu quả hơn ở 2 trường hợp:
		Không lưu trùng giữ liệu (List có thể trùng)
		Không cần lưu theo thứ tự (List lưu theo thứ tự)
	mappedBy sẽ định nghĩa @OneToMany(mappedBy="publisher") sẽ ứng với trường nào tại thực thể còn lại 
				Set<Book> books;
	mappedBy = "publisher" (phải đặt giống với tên đặt ở Book)

Users và Roles: N - 1
- Phân tích mối quan hệ
	1 user có 1 role và table_user có role_Id (owner side)
	
	User many to one role: nhiều user có thuộc role 
	@ManyToOne
	private Role role;
	//Nếu chỉ thiết lập đến đây khi chạy chương trình nó sẽ vừa tạo thêm 1 column role_id cho User vừa tạo ra một table mới role_user vì ở đây nó ko biết join 2 table như nào -> nó tự động tạo thêm table để join 2 table ở đó -> sẽ ko join trực tiếp 2 table với nhau 
	-> chúng ta phải chỉ chính xác đâu chính là nơi nối cái foreign key nối giữa khóa ngoại và khóa chính 
	-> Sử dụng mappedBy tại inverse side và @JoinColumn(name = "role_id") mục đích để ko tạo ra table role_user nữa mà giúp join trực tiếp giữa 2 table 

	@OneToMany(mappedBy="role")
	List<User> list;
	
	User many to one role: nhiều user có thuộc role 
	@ManyToOne
	@JoinColumn(name = "role_id") //nó sẽ giúp cho bảng User join trực tiếp với bảng role quan id của role 
	private Role role;
	**Bên nào xuất hiện @Many (là owner side ko cần mappedBy)
	
**Sử dụng mappedBy="" bên inverse side (bên @OneToMany)
	  @JoinColumn(name="") bên owner side (bên @ManyToOne) lúc này bên table của owner side sẽ có thêm 1 column name="" được thiết lập bởi JoinColumn 

b) quan hệ many to many 
	N - N = N - 1 + 1 - N
	Ví dụ: 
	Tutorials 		- 		tutorial_tag 		- 		Tags
	(tutorial_id)				(tutorial_id, tag_id)			(tag_id
	
	-> Nếu làm theo cách thông thường của Java Spring -> nó sẽ tự động sinh cho chúng ta 1 table đứng giữa gọi là Join Table (chứa 2 khóa ngoại mapping tới 2 khóa chính của 2 table còn lại - gọi là composite key: key dung hợp 2 khóa ngoại sẽ xác định thành 1 cặp key duy nhất) 
		
Nếu chúng ta làm thông thường mối quan hệ nhiều nhiều với java spring:
	Lưu ý: cả 2 table của chúng ta đều là owner side -> sử dụng Annotation mới là @JoinTable để nói với Java Spring biết là chúng ta dùng table nào đứng giữa để Mapping 2 đối tượng của chúng ta 
	class Tutorial {
		@ManyToMany
		@TableMapping(name = "tutorial_tag", 
			      joinColumns = {name = "tutorial_id"}, 
			      inverseJoinColumns = {"tag_id"})
		private Set<Tag> tags;
	}
	class Tag {
		@ManyToMany(mappedBy="tags")
		private Set<Tutorials> tutorials;
	}
	**Ở đây chúng ta có thể đổi chiều lại là Tag làm @TableMapping, Tutorial làm mappedBy nhưng khi làm chúng ta nên chọn 1 cái làm owner side và 1 làm inverse side mặc dù đây là quan hệ ngang hàng 

** Vấn đề phát sinh: 
	khi nó tạo table giữa nó chỉ có 2 trường là tutotial_id và tag_id mà thực tế ta muốn thêm 1 số trường thông tin khác nếu muốn thêm thì phải dùng Annotation @Embeddable ( tìm hiểu thêm )
	-> để giải quyết vấn đề theo các thủ công thì chúng ta sẽ tách mối quan hệ N - N ra làm 2 mối quan hệ: N - 1 và 1 - N 

** Cách làm N - N => N - 1 + 1 - N
Chúng ta sẽ tạo thêm 1 entity order_detail
public class OrderDetail {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private long quantity;
    private long price;

    //order_id
    //product_id
}

Thiết lập mối quan hệ: 
- Quan hệ giữa Order và OrderDetail: Order has many OrderDetail (1-N)
	Order: one to many OrderDetail
	@OneToMany(mappedBy = "order")
	private List<OrderDetail> orderDetails;

	OrderDetail: many to one Order
	@ManyToOne
	@JoinColumn(name="order_id")
	private Order order
-> đây là quan hệ BiDirectional: quan hệ 2 chiều

- Quan hệ giữa OrderDetail và Product: OrderDetail has many Product (1-N)
	OrderDetail: many to one Product (nhiều OrderDetail có cùng 1 Product)
	@ManyToOne
	@JoinColumn(name="product_id")
	private Product product;
-> đây là quan hệ UniDirectional: quan hệ 1 chiều giữa OrderDetail và Product vì chúng ta chỉ cần xác định trong OrderDetail có Product nào điều ngược lại chúng ta ko cần thiết là 1 Product thuộc những OrderDetail nào 

##6 - Mối quan hệ One to One (1-1)##
ví dụ: post <----<> postDetail 
Một bài đăng chỉ có 1 bài đăng chi tiết ( một bài đăng chi tiết chỉ thuộc 1 bài đăng )
**Annotation @OneToOne và phải xác định Owner side (nơi sở hữu Foreign Key @JoinColumn(name="") 

Nếu làm bình thường 
post(id, title)
postDetail(id, createdOn, CreatedBy, pots_id)

@Entity(name = "Post")
@Table(name = "post")
public class Post {
 
    @Id
    @GeneratedValue
    private Long id;
 
    @OneToOne(mappedBy = "post", fetch = FetchType.LAZY)
    private PostDetails details;
}

@Entity
@Table(name = "post_details")
public class PostDetails {
 
    @Id
    @GeneratedValue
    private Long id;
 
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
}

Cách tối ưu: chuyển khóa ngoại post_id -> khóa chính
post(id, title)
postDetail(pots_id, createdOn, CreatedBy)
class PostDetails {
	@Id
	private long id; 
	
	@OneToOne
	@MapsId
	private Post post;
}
ở đây chúng ta sẽ ko dùng cơ chế GenerateId nữa mà dùng @MapId để có thể biến khóa ngoại -> khóa chính (id của PostDetails -> Post_id)
	
	
=====Phần 12 Chapter 11: module upload file====
##1 - Design giao diện Admin:##

- clone https://github.com/hoidanit-be-java-spring-mvc/03-admin-template
- vào project của chúng ta tạo 1 controller để xử lý cho admin -> trang /admin
- vào tạo /view/admin/dashboard -> nơi lưu view của /admin tạo show_admin_page.jsp -> copy nội dung file index.html của template vào 

***trong template này cần chú ý file index.html có những link liên kết tỉnh để các css/js -> cần tạo những folder và file này tạo trong /webapp/resources -> sau đó vào config/WebMvcConfig.java để cấu hình lại nơi để dữ án load file css/js khi load file index.html sẽ tìm tới đường dẫn được cấu hình tới để tìm các file css/js cần thiết
***đổi các đường dẫn assets/demo/...js -> js/...js trong file show_admin_page.jsp và đưa tất cả file.js vào trong /js

##2 - Chia layout cho Admin Page(page giao diện cho các trang chức năng)##

##3 - Dùng JQuery làm chức năng Image Preview (xem ảnh khi upload lên)##

copy paste đoạn nào vào <head/> của create.jsp
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
		//đầu tiên import thư viện JQuery vào để code JQuery
                <script>
                    $(document).ready(() => {
                        const avatarFile = $("#avatarFile"); //lấy ra cái avatarFile
                        avatarFile.change(function (e) { //mỗi khi nó thay đổi
                            const imgURL = URL.createObjectURL(e.target.files[0]);
//lấy ra đường link URL, link này là 1 API browser đã làm sẵn -> nó sẽ cung cấp 1 url để hiển thị ảnh 
                            $("#avatarPreview").attr("src", imgURL); //gán URL đã lấy vào thuộc tính src của avatarPreview 
                            $("#avatarPreview").css({ "display": "block" });//thay đổi display của nó 
                        });
                    });
                </script>
-> những đoạn này chỉ xảy ra ở client front end, Java backend sẽ không làm được 

##4 - Nơi lưu trữ File##

a) Hình thức upload file
Có 2 hình thức upload file: single(upload 1 file/ 1 lần) và multiple (upload nhiều file / 1 lần)
- Khi upload multiple files:
	+ front end cần xử lý để truyền lên multiple files 
	+ back end cần xử lý để lưu nhiều files 1 lúc 
	+ vấn đề sẽ phát sinh nếu quan trọng thứ tự file upload 
(thường những file nhẹ sẽ đến server trước, nặng sẽ đến sau -> nếu chúng ta ko xử lý thứ tự file upload có thể dẫn đến các vấn đề phát sinh)

Để đảm bảo thứ tự của file upload -> upload từng file 1 (hiệu năng sẽ ko cao) để upload nhiều file = cách này có thể dùng vòng lặp cứ xong file này sẽ đến file khác (queue)

Nếu muốn upload nhiều file cùng 1 lúc -> phải cho nó chạy song song với nhau  


b) Nơi để lưu trữ file
- Hình thức 1: lưu trữ qua các dịch vụ online ví dụ: Amazon(S3), cloudflare(R2)
	Ưu điểm: truy cập mọi lúc mọi nơi. tự động backup giữ liệu
	Nhược điểm: pay as you go (dùng bao nhiêu trả bấy nhiêu, hoặc mua theo gói cước) 

**Các hình thức mà các ứng dụng ko cần trả phí thực hiện là đẩy dữ liệu về cho người dùng tự lưu trữ 
- Hình thức 2: lưu trữ file trong database 
	lưu trữ trong mySQL hỗ trợ định dạng blob và clob (khóa học sern trên ytb) 
	Ưu: miễn phí có thể lưu tối đa 4Gb/file
	Nhược: tốc độ IO chậm, phải tự backup 

- Hình thức 3: Lưu trữ tại server/lưu trữ tại nơi chúng ta viết code 
	Ưu: miễn phí, tốc độ IO nhanh hơn database (vì lưu raw file) 
	Nhược: tự backup dữ liệu, tối ưu hóa IO 

c) Cách thức lưu trữ hình thức 3
- Nguyễn tắc upload file: với hình thức lưu trữ file tại server (tức là lưu tại folder chứa source code/ hoặc folder local trên máy tính) 
	Bước 1: Client gửi file lên server (view)
	Bước 2: server lưu file vào folder quy định trước
	Bước 3: kiểm tra client có thể truy cập vào được file đã upload hay không (hiển thị ảnh ra view) 

d) Upload file với JSP 
- Sử dụng đối tượng MultipartFile để lấy file từ client gửi lên cho chúng ta 
- Logic để lưu trữ file:
	Chuyển file sang dạng bytes: byte[] bytes = file.getBytes(); -> Lưu trữ dưới dạng stream 
	Sau đó dùng BufferedOutputStream stream-> để tạo ra lại file khác giống với file ban đầu 
	sau đó dùng stream.write() để di chuyển file tới nơi lưu 

e) Hoàn thiện chức năng upload file (part1)
**nên convert lại tên file khi upload lên -> dưới dạng khác để tránh khi user upload nhiều file tên giống nhau 
**chúng ta chỉ cần lưu tên của file ảnh vào database ko cần lưu đường dẫn vì mình đã config nó nằm ở avatar/

Bước 1: mapping thêm Role (thuộc tính Object của User) 
Bước 2: Để có thể gửi file lên server -> thêm thuộc tính enctype="multipart/form-data" -> vì file ko thể gửi dưới dạng string lên server được mà cần được chuyển sang dạng binary -> tối ưu
Bước 3: thêm thuộc tính name cho <input type="file"> để server có thể thông qua đây lấy được dữ liệu (lưu ý chỗ này chỉ có thể dùng attr name ko dùng được id, class hay path của form:) 
Bước 4: lấy file ở server (controller) -> dùng Annotation @RequetsParam("nameFile") MutilpartFile[kiểu giá trị] file[tên biến] -> trong file này ở server nó sẽ có 1 attr value chứa thông tin file (là các số dữ liệu binary) khi đã được chuyển đổi
Bước 5: Lưu trữ file
	- cấu hình thêm trong file .properties 
	spring.servlet.multipart.max-file-size=50MB //dung lượng tối đa khi upload 1 file 
	spring.servlet.multipart.max-request-size=50MB //tổng request bao gồm all files khi gửi lên server 
https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties.web

h) Hoàn thiện chức năng upload file (part2)

hướng dẫn upload multiple file
	- ở thẻ input thêm attr multiple
	- @RequetsParan("nameFile") MutilpartFile[] file (dùng kiểu array ở đây)
dùng for lặp link hướng dẫn:
https://www.digitalocean.com/community/tutorials/spring-mvc-file-upload-example-single-multiple-files

https://spring.io/guides/gs/uploading-files

Giải thích code: 
public String CreateUser(Model model, @ModelAttribute("newUser") User user,
            @RequestParam("nameAvatarFile") MultipartFile avatarFile) {
        try {
            byte[] bytes = avatarFile.getBytes();
            String rootPath = this.servletContext.getRealPath("/resources/images");
            File dir = new File(rootPath + File.separator + "avatar");
            if (!dir.exists()) {
                dir.mkdirs();
            }
            // Create the file on server
            File serverFile = new File(dir.getAbsolutePath() + File.separator + System.currentTimeMillis() + "-"
                    + avatarFile.getOriginalFilename());
            BufferedOutputStream stream = new BufferedOutputStream(new FileOutputStream(serverFile));
            stream.write(bytes);
            stream.close();
        } catch (IOException ex) {
            System.out.println(ex);
        }
        // this.userService.handleSaveUser(user);
        return "redirect:/admin/user";
    }

byte[] bytes = avatarFile.getBytes();
- lấy hình ảnh dưới dạng binary
	
String rootPath = this.servletContext.getRealPath("/resources/images");
- đường link mình truyền vào là relative path -> câu lệnh này giúp lấy absolute path trên chính máy tính đang dùng 
ServletContext là lớp tổng quát được spring viết bọc cả Servlet - this.servletContext.getRealPath sẽ giúp chúng ta lấy đường link 
- thường 1 cấu trúc của 1 ứng dụng web sẽ có thư mục webapp khi build dự án nó sẽ lưu vào đây -> mặc định khi dùng this.servletContext.getRealPath("") -> mặc định trả ra địa chỉ chính xác đến thư mục webapp -> nó chỉ trả tới địa chỉ webapp chúng ta phải truyền thêm cho nó địa chỉ cụ thể muốn lưu vào cụ thể ở đây là /resources/images 	

File dir = new File(rootPath + File.separator + "avatar");
- tìm nơi nào chúng ta muốn lưu file chúng ta cộng chuỗi:
	địa chỉ tới images + "/" + tên thư mục nơi lưu

if (!dir.exists()) {
   dir.mkdirs();
}
- nếu thư mục đó chưa tồn tại ta sẽ tạo mới nó 

File serverFile = new File(dir.getAbsolutePath() + File.separator + System.currentTimeMillis() + "-"
                    + avatarFile.getOriginalFilename());
- tạo ra tên file chúng ta muốn lưu 
- dir.getAbsolutePath() + File.separator: đường link lưu trữ thư mục được check hoặc tạo ra bởi if ơ trên + "\"
- System.currentTimeMillis() + "-" + avatarFile.getOriginalFilename()); mili seconds + tên file: để sửa đổi tên file tránh trùng lặp
//cơ chế để tạo tên tránh trùng lặp trong 100 năm: uuid của Mongo DB 

BufferedOutputStream stream = new BufferedOutputStream(new FileOutputStream(serverFile));
dùng Buffer truyền vào file chúng ta muốn lưu 

stream.write() //lưu file

Stream.close() //để chống leak dữ liệu 

##5 - Các hình thức mã hóa data(Endcoding, hashing, encryption)##

a) Endcoding - Decoding (mã hóa - giải mã) 
	- Endcoding là quá trình chúng ta biến đổi data từ dạng này sang dạng khác
		Vidu: input: "hello world"
		      output: "101000010001"
		+ không sử dụng key/password nào để mã hóa (nhược điểm)
		+ có thể bị giải mã chuỗi đã được encoding 
		+ thông thường ko dùng để bảo vệ data 
		+ được dùng để compression(nén dữ liệu), Streaming 
		+ các định dạng sử dụng encoding: base64, .mp3, .mp4

b) Hashing
	Vidu: input: "hello world"
	      output: "333bef68dg8090q09302"
	Hashing là cách chúng ta băm  data thành 1 chuỗi string đặc biệt(hash)
	+ đây là quá trình 1 chiều ko thể giải mã 1 chuỗi đã được hash để lấy lại dữ liệu ban đầu
	+ Nên làm cho các data mang tính cần được bảo mật (password)
	+ Các bước: 
		Lúc đăng ký:
		Hash input đầu vào (băm dữ liệu nhập vào) thành 1 chuỗi ngẫu nhiêu
		sau đó lưu vào database 
		
		Lúc đăng nhập:
		Hash input đầu vào (băm dữ liệu nhập vào) thành 1 chuỗi 
		so sánh với chuỗi đó với chuỗi đã được lưu tron database 

c) Encryption
	vừa có Tính bảo mật cao hơn - vừa có tính 2 chiều (encoding - decoding)
	nâng cấp từ en-de coding được sử dụng để trao đổi dữ liệu 
	mục đích: để chúng ta mã hóa để gửi dữ liệu - giải mã để nhận dữ liệu 

	Nhược điểm: 
		Giới hạn về mặt dung lượng
		kế thừa những thuật toán phức tạp

	được áp dụng như messager (tin nhắn được lưu trữ trong db sẽ được mã hóa và khi sao lưu ra sẽ được giải mã)

d) Hash user password:
** Lưu ý: dữ liệu ở đây chúng ta chưa validate

đọc tham khảo về hashing: https://docs.spring.io/spring-security/reference/features/authentication/password-storage.html#authentication-password-storage-bcrypt

cách code: https://www.baeldung.com/spring-security-registration-password-encoding-bcrypt

code dependency injection thêm private final PasswordEncoder passwordEncoder vào UserController
	khi dùng passwordEncoder thì Spring security sẽ dùng thuật toán mặc định để hashing
	-> muốn dùng thuật toán BCryptPasswordEncoder để hash thì chúng ta ko thể dùng trực tiếp BCryptPasswordEncoder được cần phải overide lại PasswordEncoder để return về BCryptPasswordEncoder

	Muốn dùng cái này chúng ta phải khai báo dưới dạng Beans để ghi đè lên cấu hình mặt định của spring security dùng Bean để khi ứng dụng chạy lên thì nó dã ghi đè rồi 
	Phải cấu hình lại Spring security 

Tạo thêm SecurityConfiguration.java trong config để cấu hình Spring security
class này dùng 2 Annotation @Configuration, @EnableMethodSecurity(securedEnabled = true) để cho spring biết ta cấu hình spring security ở đây 
	Trong class này chúng ta cần khai báo BCryptPasswordEncoder dưới dạng Beans:
		  @Bean
		  public PasswordEncoder passwordEncoder() {
		        return new BCryptPasswordEncoder();
	          }
cấu hình xong chúng ta đã có thể sử dụng -> mật khẩu sau khi hashing có thể điều chỉnh ngắn dài = cách truyền tham số vào thuật toán BCryptPasswordEncoder

e)Lưu lại User vào database: 
- chúng ta còn thiếu rold_id trong bảng role -> view nó trả về 1 role_name 
-> chúng ta cần viết 1 service lấy role_id = role_name 

-> sau đó add đối tượng role tìm được khi lưu Spring data sẽ xử lý và chỉ lưu id của nó thôi 

g) Xử lý update(giống create) 

h) xử lý delete

====Phần 13 chapter 12 Module Product====

##1 - Design giao diện trang chủ##

a) Tạo giao diện cho "/" home page
- tạo 1 controller cho home page
- clone https://github.com/hoidanit-be-java-spring-mvc/04-client-template.git
- tạo 1 folder client bên trong webapp/resources để lưu tài nguyên của giao diện home page tránh trùng với admin
	** cấu hình thêm /client -> /resources/client
- copy all folder của template trừ folder scss (scss là cách viết css ngắn ngọn hơn bth và cần cấu hình trc mới đọc hiểu được spring chưa cấu hình ko đọc đc) vào client/

- đổi lại đường dẫn trong file .jsp 


b) Tạo Giao Diện cho Product Detail


c) Chỉnh sửa lại giao diện Product Admin

d) Valid dữ liệu (input đầu vào)
- Kiểm tra tính hợp lệ của dữ liệu -> Hạn chế dữ liệu rác 

- Nên validate ở Front-end hay Back-end
	Front-end: 
	Html: dùng các thuộc tính của các tag như type="", required, ...
	Javascript: validate trước khi gửi dữ liệu đi (đối với form khi bấm submit -> validate)
	-> Ưu điểm tăng trải nghiệm người dùng 
	-> Nhược có thể hack được -> thiếu sự bảo mật 

	Back-end: (server)	
	-> Tăng tính bảo mật (ko bị hack được)

- Validate với Java Spring
Cách 1: sử dụng jakarta.validation (Jakarta Bean Validation)
	Đây là cái tích hợp sẵn khi dùng mô hình MVC 
	Tài Liệu: https://beanvalidation.org/
	Ví dụ: https://spring.io/guides/gs/validating-form-input

	Cần 2 thư viện: 
	jakarta.validation
	org.springframework.validation.BindingResult
	
	Cần thêm thư viện: 
	<dependency> 
	    <groupId>org.springframework.boot</groupId> 
	    <artifactId>spring-boot-starter-validation</artifactId> 
	</dependency>	

	Spring đã giúp kết nối 2 thư viện này rồi chỉ cần sử dụng 
Cách 2: Sử dụng Hibernate Validator(thư viện ở ngoài) 
	Đa số trước giờ code dùng JPA chỉ dùng Hibernate để cấu hình vì hiện tại JPA đang giải quyết được vấn đề của ứng dụng chưa cần dùng tới Hibernate (Hibernate kế thừa JPA để phát triển thêm)

	Khi làm việc với session này tới backend -> sử dụng hibernate chứ hiện tại chúng ta mới chỉ dùng CRUD chỉ cần dùng JPA 
	Tài Liệu: https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#preface
	Ví dụ:  https://www.geeksforgeeks.org/hibernate-validator-with-example/
	Khi xem ví dụ đa số thư viện cài từ javax đây là version cũ -> nên dùng lại jakarta version mới 
	
	Lưu ý khi dùng Hibernate Validator cần cài thêm thư viện:
	<dependency>
	    <groupId>org.hibernate.validator</groupId>
	    <artifactId>hibernate-validator</artifactId>
	    <version>8.0.1.Final</version>
	</dependency>


**Trong ứng dụng này dùng cách 1 Jakarta.validation

##2 - Validate Model##

- Model User: 

Tài liệu: https://spring.io/guides/gs/validating-form-input

Bước 1: Decorate Model với annotation
https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html#builtinconstraints

<dependency> 
    <groupId>org.springframework.boot</groupId> 
    <artifactId>spring-boot-starter-validation</artifactId> 
</dependency>

Bước 2: Validate tại controller 
Trước hết cần vào domain vào entity cần valid dùng những Annotation như @Email, @min, @max vào những thuộc tính cần validdate
sau đó Để validate dữ liệu của 1 User trước khi lưu xuống data base ta cần đặt Annotation @Valid trước đối tượng User đó trong controller 

Bước 3: Get message lỗi sau khi được Validate dùng Annotation @Binding Result (sẽ hiển thị kết quả của quá trình Validate) cũng đặt trong tham số của controller xử lý @Valid và tham số bindingResult nameObjectBindingResult này cần đặt ngay sau tham số @Valid nếu ko sẽ ko trả ra kết quả mong muốn

@Binding Result   
https://stackoverflow.com/a/7384449

   List<FieldError> errors = nameObjectBindingResult.getFieldErrors();
    for (FieldError error : errors ) {
        System.out.println (error.getField() + " - " + error.getDefaultMessage());
    }
-> getField() sẽ hiển thị các trường bị lỗi khi có lỗi thì chương trình sẽ ko chạy bình thường được -> chúng ta cần return nó về lại /admin/product/create khi bị lỗi chứ ko redirect vì nếu rediretc nó sẽ mất thông báo lỗi mà nó load function của địa chỉ đó để chạy 
   if(nameObjectBindingResult.hasErrors()) return "/admin/product/create";

Bước 4: để hiển thị errors ra view JSP form cũng hỗ trợ cho chúng ta tag <form:errors path=""/> điền path của đối tượng cần kiểm tra 
	-> tag này sẽ tự generate 1 tag <span> để hiển thị lỗi

Đối với những tag của <form:> thì phải dùng thuộc tính của nó để generate ra lại 1 tag của html 
	ví dụ: <form:errors cssClass="error" /> 
	-> lên giao diện khi có error <span class="error"> </span>

để thêm hiệu ứng dùng Bootstrap 5: https://getbootstrap.com/docs/5.0/forms/validation/#server-side
Đối với span, thêm class “invalid-feedback” //mặc định display:none
Đối với input, thêm class “is-invalid” // thêm vào khi có lỗi 
Về error tags:
https://docs.spring.io/spring-framework/reference/web/webmvc-view/mvc-jsp.html#mvc-view-jsp-formtaglib-errorstag

https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/web/servlet/tags/form/ErrorsTag.html

Check theo điều kiện có valid hay không ?
https://mkyong.com/spring-mvc/spring-mvc-form-check-if-a-field-has-an-error/

để thêm class is-invalid vào input khi có lỗi có 2 cách

Cách 1: dùng Annotation Spring:bind
Bước 1: thêm annotation đó vào (trước có thêm form rồi nên ko cần thêm form nữa)
  <%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>

Bước 2:
 <spring:bind path="newUser.password"> //tên đối tượng . tên thuộc tính cần kiểm tra 
          <form:input type="password"
                class="form-control ${status.error ? 'is-invalid' : ''}"
                path="password" />
</spring:bind>
<form:errors path="password" cssClass="invalid-feedback" />

Nhờ Spring:bind chúng ta sẽ có biến status biến này sẽ trả ra true (có lỗi thêm class) hoặc false (ko)



Cách 2: dùng thư viện jstl/core đã cài sẵn dùng c: để sử dụng các function của jstl core 
	
     Gán giá trị cho 1 biến ở đây chúng ta set giá trị cho biến nameHasBindError = lỗi khi nhập sai pw
     <c:set var="nameHasBindError">
          <form:errors path="password" />
     </c:set>

     Kiểm tra cái biến nameHasBindError nếu nó có giá trị thì thêm class is-invalid, nếu ko có lỗi thì ko thêm
     <form:input type="password"
          class="form-control ${not empty nameHasBindError? 'is-invalid':''}"
          path="password" />

     <form:errors path="password" cssClass="invalid-feedback" />

Hoàn thiện Module Product: chỉnh sửa giao diện các ảnh ở phần admin bị bể và format giá tiền
	<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
	
		
=====Chapter13: Module Auth (Session vaf Spring Security)=====

##1 - DTO (Data Transfer Object)##
- Trong form đăng ký thì có các trường như First Name, Last Name, Confirm Password -> mà trong Database ko có chỉ có Fullname và Password -> để xử lý trường hợp này t dùng DTO Design Pattern
- Sơ lược hoạt động của DTO: A (dữ liệu thô) - B (dữ liệu đã xử lý để lưu vào Database)
	Có thể thêm hoặc bớt data từ A để biến đổi nó thành B để phục vụ tốt cho nhu cầu của chúng ta
	Cụ thể ở đây: chúng ta tạo 1 class lưu trữ thông tin đăng nhập(Firstname, Lastname, email, Password, Confirm Password) 'thông tin này ko lưu vào Database' từ những thông tin này t chuyển đổi nó thành 1 User thông qua Mapper

- Mình có thể tạo 1 class khác để viết mapper nhưng ở đây để đơn giản thì ta viết mapper là một method trong các service luôn 


##2 - Validate dữ liệu##
- Thêm các file .java trong folder validate trong phần service
- Hiện tại: trong các domain chúng ta dùng cái Annotation của thư viện cung cấp cho chúng ta để valid dữ liệu
	+ Chúng ta có thể valid thủ công = code trong controller nhưng khuyết điểm là khó để đưa những lỗi này lên View 
	+ Ở các trang create, update ở Admin thì chúng ta chỉ dùng BindingResult nếu như có lỗi nó sẽ tự động ném lỗi qa View 
-> việc tự valid thủ công nếu dự án lớn sẽ rất piền -> chúng ta sẽ tự sẽ tự tạo ra các Annotation để valid theo nhu cầu 
- Tạo Annotation: 
	public @interface StrongPassword: đây là định nghĩa ra Annotation StrongPassword pải có @interface 
	@Constraint(validatedBy = StrongPasswordValidator.class) -> nói cho java biết là Annotation này làm gì 
	@Target({ ElementType.METHOD, ElementType.FIELD }) -> Phạm vi hoạt động của Annotation: trên 1 element, 1 class hay trên 1 method 
	@Retention(RetentionPolicy.RUNTIME) -> khi nào thì Annotation này chạy 
	@Documented: Cho phép annotation này xuất hiện trong tài liệu Javadoc.

	Cần các trường: 
		+ String massage() default "..." ->  Tin nhắn mặc định nếu ràng buộc bị vi phạm 
		+ class<?>[] groups() default {};
		+ class<? extend Payload>[] payload() default {};

- Giải thích: 
	+ @Constraint: Đánh dấu rằng đây là một annotation dùng để ràng buộc (constraint).
	+ Payload: Dùng để cung cấp thêm thông tin meta về constraint, thường để nhóm thông tin lỗi.
	
	+ các Annotation như Target, Retention, Documented là các Annotation Meta 
	
	@Constraint(validatedBy = StrongPasswordValidator.class)
	+ Liên kết annotation @StrongPassword với lớp StrongPasswordValidator, nơi logic kiểm tra sẽ được thực hiện.
	 

- Sau khi tạo Annotation ta cần định nghĩa nơi logic kiểm tra sẽ được thực hiện chính là phần Constraint valid = StrongPasswordValidator.class
	Class StrongPasswordValidator: 
		public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {

		    @Override
		    public boolean isValid(String value, ConstraintValidatorContext context) {
		        // check if string contains at least one digit, one lowercase letter, one
		        // uppercase letter, one special character and 8 characters long
		    return value.matches("^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=!*()]).{8,}$");
		    }
		}
	Để biến class StrongPasswordValidator thành 1 validator ta cần kế thừa lại ConstraintValidator những kiểu dữ liệu truyền vào này là những kiểu generate dùng template mình có thể truyền vào những kiểu dữ liệu bất kì 
		public interface ConstraintValidator<A extends Annotation, T> {
		   default void initialize(A constraintAnnotation) {
		   } 
		   boolean isValid(T var1, ConstraintValidatorContext var2); 
		}
	Ở đây: 
		+ initialize là 1 interface là default method ko cần kế thừa chỉnh sửa nó 
		+ isValid: cần kế thừa và chỉnh sửa nó sao cho phù hợp với mình validate viết override ở ngay trong class 	
			-> trả ra False nếu vi phạm nguyên tắc bạn đề ra - True ngược lại 
	StrongPasswordValidator
	-> nhưng nếu ta làm như thế này thì nó chỉ valid được cho từng trường dữ liệu thôi 
	-> để tối ưu code nhất thì chúng ta cần phải valid cho cả 1 class 
	@Constraint(validatedBy = RegisterValidator.class)
	@Target({ ElementType.TYPE }) // Adjusted to apply to the class level
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	public @interface RegisterChecked {

	    String message() default "User register validation failed";

	    Class<?>[] groups() default {};

	    Class<? extends Payload>[] payload() default {};
	}
	- Đầu tiên chỉ lại Target ElementType.TYPE để dùng Annotation này trang trí cho 1 class 
	- Tiếp theo cần sửa đổi lại logic chúng ta validate 
	public class RegisterValidator implements ConstraintValidator<RegisterChecked, RegisterDTO> {

    	@Override
    	public boolean isValid(RegisterDTO user, ConstraintValidatorContext context) {
        	boolean valid = true;

	        // Check if password fields match
        	if (!user.getPassword().equals(user.getConfirmPassword())) {
	            context.buildConstraintViolationWithTemplate("Passwords must match")
        	            .addPropertyNode("confirmPassword")
                	    .addConstraintViolation()
	                    .disableDefaultConstraintViolation();
        	    valid = false;
        	}

	        // Additional validations can be added here

        	return valid;
    	}
	- Giải thích code:
		context.buildConstraintViolationWithTemplate("Passwords must match") 
		//mỗi lần gặp lỗi thì báo ra lỗi Passwords must match
		addPropertyNode("confirmPassword")
		//trường thông tin báo lỗi là confirmPassword - mapping với View 

	- Để sử dụng Annotation này Vadlidate cho 1 class:
		+ đặt Annotation phía trên tên class
		+ dùng 2 Annotation Valid để kiểm tra dữ liệu và BindingResult để truyền lỗi qa View 
			Valid: khi mà String qét thấy 1 biến dùng Valid thì nó sẽ chạy vào trong domain của biến đó rồi xét xem có các ràng buộc/constraint Validate dữ liệu ko -> nó sẽ chạy vào các Annotation là Constraint để check -> nó sẽ check hàm isValid 
	
- Tiếp theo sau khi đã kiểm tra lỗi: 
	+ hiển thị ra View thông báo lỗi (dùng BindingResult để quăng qa View và dùng các thẻ Error để hiển thị)
	+ liên kết xuống database để check email (thêm Annotation Service cho Validator để thực hiện tiêm userService vào để lấy email từ database lên check)

##3 - Spring Security##

a) enable Spring security lên: vào trang class main LaptopshopApplication.java
	@SpringBootApplication(exclude = org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class) //comment lệnh này 
	@SpringBootApplication mở lên này và để mặc định
	Ở đây nếu mở SpringBootApplication lên thì nó sẽ không hoạt động được vì:
		- thứ nhất chúng ta đã cấu hình lại ở phần config mã hóa Password -> cần phải chỉnh password trong file properties = mã hóa theo chuẩn đã cấu hình 
		- và 1 số lý do khác :vvv
	khi enable nó lên thì khi truy cập vào app cần login và trang login này sẽ ghi đè lên /login đang custom

b) chúng ta cần back code lại trước đó để kiểm tra luồng hoạt động mặc định của Spring Security
Mô hình hoạt động của Spring Security trong việc đăng nhập = trang mặc định /login và tài khoản thì tự cấu hình trong .properties: 
	1 - nhập và submit thông tin tài khoản từ giao diện (form)
	2 - Thông tin này sẽ được Spring Security đưa qa các Filter Chains mặc định để kiểm tra về thông tin người dùng thì sẽ có qua UsernamePasswordAuthenticationFilter trong class filter này cần nhận về 1 Authentication -> để lưu nó vào SecurityContextHolder (đây là nơi để xác thực việc đăng nhập)
	(muốn có authentication -> thì cần lấy được dữ liệu thông tin user đã có lên so sánh với dữ liệu đầu vào)
	(nhưng dữ liệu của chúng ta có nhiều hình thức lưu trữ như là lưu ở memory/RAM, database, bên thứ 3, ...)
	-> Spring Security cung cấp nhiều phương thức để lấy dữ liệu như: 
		DaoAuthenticationProvider(nếu lưu dữ liệu ở database hoặc memory/RAM)
		LdapAuthenticationProvider 
		OpenIdAuthenticationProvider 
		JwtAuthenticationProvider 
		...
	tất cả những class này kế thừa interface AuthenticationProvider
	và để Spring xác định được đối với mỗi dự án thì dùng phương thức để lấy dữ liệu nào -> Spring dùng các class kế thừa từ AuthenticationManager như class ProviderManager

	2.1 - Trong UsernamePasswordAuthenticationFilter sẽ gọi đến ProviderManager ở đây sẽ tạo ra một vòng lặp lặp qa tất cả các Provider xem Provider nào hợp với cấu hình của dự án và trả ra 1 Provider hợp lý đối với dự án 

	2.2 - Sau khi có Provider rồi thì để kết nối xuống database ở đây thì cho mọi Provider Spring Security cùng cấp 1 interface UserDetailsService trong này sẽ có: các class kế thừa nó như
		InMemoryUserDetailsService(nếu chúng ta ko cầu hình thì nó sẽ chọn cái này làm mặc định tức là lấy dữ liệu qua Ram/dữ liệu lưu trong code tức là account config trong .properties)
		LdapUserDetailsService
		....
		hoặc là CustomUserDetailsService(loại người dùng tự kế thừa lại UserDetailsService và custom nó)
		Đặc biệt trong Interface này chỉ có 1 method là loadUserByUsername(username) chúng ta cần custom cái method này sao cho hợp với dự án của chúng ta với:
			input: username nhập vào ở view
			output: UserDetails ở đây nó sẽ trả về cho Provider gọi nó (trong này lưu thông tin như password)
	2.3 - cuối cùng là việc so sánh password Spring Security cung cấp 1 interface PasswordEncoder sẽ có 1 class kế thừa nó và được init khi đã lựa chọn ra được 1 Provider 
		input: UserDetails (bao gồm password đã bị mã hóa theo dự án hiện tại thì mã hóa theo BCryptPasswordEncoder chúng ta đã override sơ lại cái PasswordEnconder trong phần config) và password lấy từ phía người dùng nhập vào 
		output: Authentication Object trả về lại cho Filter UsernamePasswordAuthenticationFilter
	3 - Khi UsernamePasswordAuthenticationFilter có data là authentication -> thì nó sẽ lưu data này vào 
	SecurityContextHolder
		SecurityContext
			Authenticaion(user data: username, permission, ... ở đây ko lưu password)
	và sẽ chèn dữ liệu này vào SecurityContextHolderFilter để thực hiện kiểm tra người dùng 

Sau khi xong quá trình login của Spring Security có 2 trường hợp xảy ra: 
	- Mỗi lần người dùng F5/refresh lại hệ thống tức là chúng ta gửi 1 request mới đến server -> thì Spring Security sẽ ko chạy lại all bước tùy theo cơ chế mà người dùng cấu hình như dùng Session thì nó sẽ vào kiểm tra SecurityContextHolderFilter đối với filter này sẽ kiểm tra bên trong SecurityContextHolder có lưu thông tin người dùng đăng nhập không nếu có thì người dùng sẽ tiếp tục sử dụng không cần phải đăng nhập nữa 
	- Trường hợp sai thông tin đăng nhập
		sẽ dùng ExceptionTranslationFilter filter này sẽ có trách nhiệm báo lỗi lại cho coder

Chung quy lại: thì tất cả các phần Java Spring đã làm sẵn cho chúng ta rồi ta chỉ cần kế thừa và custom cách query kết nối xuống database ở UserDetailsService hoặc nâng cao hơn là tự viết 1 Filter ko dùng Filter mặc định của Spring Security 

c) tiến hành thực hiện trên code = chế độ Debug để xem quá trình chạy 
Ở đây sẽ chạy chế độ debug ở những class trong thư viện của Spring Security  
Mở nhanh file (đã compiled) với VSCode:
nhấn Ctrl + T
- đầu tiên khi nhập dữ liệu vào Form login và nhấn submit -> Spring Security sẽ bắt đầu đưa dữ liệu qua các Filter
Thứ tự các file class cần debug: chạy qa các filter đến UsernamePasswordAuthenticationFilter
1 - UsernamePasswordAuthenticationFilter(đặt breakpoint dòng 35)
	trong class này để ý attemptAuthentication() hàm này sẽ trả về 1 biến authenticate 
		return this.getAuthenticationManager().authenticate(authRequest);
		nhấn ctrl bấm vào authenticate nó sẽ dẫn đến Interface AuthenticationManager

2 - AuthenticationManager
	đây chỉ đơn giản là 1 interface có phương thức authenticate chúng ta cần đi đến class implement interface này và override method đó để hoạt động 
	bấm chuột phải vào class AuthenticationManager và chọn "go to implementations" chọn class ProviderManager

3 - ProviderManager(đặt breakpoint tại hàng 66)
	trong class này để ý method override là authenticate() ta có 1 vòng lặp để lặp qua tất cả các Provider và trả ra Provider phù hợp với cấu hình dự án hoặc đưa dữ liệu vào Provider đó luôn 
	do chúng ta dùng username, password để đăng nhập kết hợp với database nên nó sẽ chạy vào DaoAuthenticationProvider

4 - DaoAuthenticationProvider(đặt breakpoint dòng 53)
	trong class này để ý method retrieveUser() trong này sẽ gọi đến Service (UserDetailsService) nó sẽ gọi đến method duy nhất của Service này là loadUserByUserName(username) 
	khi click vào loadUserByUserName nó sẽ dẫn đến Interface UserDetailsService
	-> chúng ta cần đến class kế thừa và override phương thức này và đối với dự án của chúng ta chưa cấu hình gì hết mà chỉ mới cài Spring Security thì mặc định nó sẽ dùng class InMemoryUserDetailsManager

5 - InMemoryUserDetailsManager(đặt breakpoint dòng 123)
	bên trong này nó cần viết logic để query dữ liệu
	chú ý hàm loadUserByUsername() -> trả ra UserDetails Object (data là gồm thông tin người dùng - username, pw)
	sau khi có data rồi thì Spring Security sẽ chạy vào SecurityContextHolderFilter 

6 - SecurityContextHolderFilter(đặt breakpoint dòng 40)
	chú ý hàm doFilter() giúp set context/thông tin người dùng vào đây (thông tin này đã bỏ qua pw)
	có 1 biến để lưu dữ liệu deferredContext ban đầu nó sẽ load từ Request từ client để kiểm tra giá trị của biến này thì dùng deferredContext.get() vì nó có kiểu dữ liệu Supplier đây là 1 interface chỉ có 1 method Get

Watch variable: bấm dấu + và thêm dữ liệu này vào để kiểm tra nó
	deferredContext.get()
		chứa authentication

Sau khi đặt all tiến hành chạy ở chế độ Debug: 
	1 - truy cập vào Url nó sẽ chưa hiển thị lên trang login vì Spring Security đầu tiên nó sẽ chạy vào SecurityContextHolderFilter để kiểm tra có data (người dùng đã đăng nhập và chưa logout trước đó chưa) nếu có thì nó sẽ bỏ qua login mà vào trang chủ luôn 
		ban đầu deferredContext.get() chứa authentication = null
	2 - sau khi nó kiểm tra trong đó xong nếu authentication = null nó sẽ hiển thị lên trang login 
	
	3 - sau khi nhập thông tin và nhấn submit nó vẫn sẽ chạy vào SecurityContextHolderFilter đầu tiên sau khi check authentication = null nó sẽ chạy vào UsernamePasswordAuthenticationFilter
	
	4 - trong UsernamePasswordAuthenticationFilter nó có gọi đến method authenticate() của ProviderManager(kế thừa và override từ interface AuthenticateManager) 
		trong này nó sẽ có 1 vòng lặp để kiểm tra chúng ta dùng Provider nào ứng với việc mà mình login ở đây chúng ta dùng username và password cũng ko dùng third party -> sau khi chạy xong vòng lặp nó sẽ chạy vào DaoAuthenticationProvider

	5 - trong DaoAuthenticationProvider nó sẽ chạy vào method retrieveUser ở đây nó sẽ gọi đến Service (UserDetailsService) nó sẽ gọi method loadUserByUsername ở đây chúng ta ko cấu hình database nên mặc định nó sẽ chạy đến class InMemoryUserDetailsService nơi kế thừa và override lại loadUserByUsername

	6 - trong InMemoryUserDetailsService có loadUserByUsername được override -> trả về thông tin của User (UserDetails)
	
	7 - Sau khi có UserDetails trả về cho UsernamePasswordAuthenticationFilter rồi + password được lấy từ login -> PasswordEndcoder để mã hóa password và so sánh -> rồi trả về authentication

	8 - từ đó chúng ta đã có data -> SecurityContextHolderFilter để lưu data lưu vào trong deferredContext nó chứa 
		authentication: 
			trạng thái authenticated: true
			quyền hạn  user authorities: ở đây là 1 array nếu ko có cầu hình thì length = 0
			credential = null (password của người dùng)
			details chứa:
				địa chỉ 
				session sau này nếu dùng session nó sẽ lưu vào đây
			principal là id của người dùng 
				username = ...
				password = null
				....
-> hoàn thành việc đăng nhập và trở về trang chủ - ở đây nếu chúng ta refresh lại trang chủ thì nó sẽ chạy vào SecurityContextHolderFilter để kiểm tra ngay bây h trong context nó có lưu session(mặc định)/thông tin người dùng không -> bỏ qua phần login 

d) Custom logic ở loadUserByUsername giúp login với Spring Security 
1 - Mở Spring Security lên 
	cmt đoạn code này:
// @SpringBootApplication(exclude = org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class)
	Dùng code này:
@SpringBootApplication

2 - Khi đã enanle Spring Security -> chạy chương trình vào bất kì Url nào nó cũng sẽ redirect về trang login mặc định của Spring Security 

3 - Custom lại luồng đăng nhập 
	- Bên trong phần Config Security đang override lại passwordEnconder để băm password -> BCryptPasswordEndcoder -> chúng ta cần phải nói cho Spring Security dùng cái này để hash password
	- Chỉnh lại không cho nó lấy dữ liệu mặc định InMemory (lấy tài khoản được config trong .properties) -> mà cấu hình lại để nó lấy từ Database 
	
	- Chúng ta sẽ viết logic lại cho UserDetailsService đây là 1 Interface -> kế thừa lại nó để ghi đè lại cấu hình mặc định (là chuyển từ dùng InMemory -> database)
	Tạo 1 class CustomUserDetailsService trong Service implements UserDetailsService và Override lại abstract method của nó 
	@Override
	    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
	    }
	Function này yêu cầu chúng ta trả ra 1 UserDetails nhưng đối với dự án này chỉ có thể Return về User (class tự tạo ra)
	
	Tìm hiểu về interface UserDetails extends Serializable gồm các trường: 
		Collection<? extends GrantedAuthority> getAuthorities();
	   	String getPassword();
   		String getUsername();
   		boolean isAccountNonExpired();
   		boolean isAccountNonLocked();
	   	boolean isCredentialsNonExpired();
   		boolean isEnabled();
	đây là 1 Interface ko hề có hàm tạo chúng ta cần tìm lớp con kế thừa nó để return về lớp con đó ở Function loadUserByUsername -> nó sẽ tự ép kiểu về UserDetails (Up casting)
	-> bấm chuột phải vào interface + 'go to implementations' -> có class User (đây là class của Spring Security)
	class User implements UserDetails, CredentialsContainer gồm: 
	private String password;
   	private final String username;
   	private final Set<GrantedAuthority> authorities; //quyền, set sẽ đảm bảo các giá trị là độc quyền
	private final boolean accountNonExpired;//tài khoản hết hạn hay chưa
   	private final boolean accountNonLocked;//tài khoản có bị khóa không
   	private final boolean credentialsNonExpired;//mật khẩu hết hạn chưa (kiểu bao nhiêu tháng đổi mk 1 lần)
   	private final boolean enabled;//tài khoản có kích hoạt chưa 
	... (một số thông tin phục vụ cho nhiều loại dự án khác nhau)
	Và nó có hàm tạo để tạo ra 1 class này 
	public User(String username, String password, Collection<? extends GrantedAuthority> authorities) {
      		this(username, password, true, true, true, true, authorities);
	}
	-> có một số thông tin khá trùng với User tự tạo -> truyền dữ liệu từ User tự tạo vào đây để Return về 1 User của hệ thống để nó tự Ép kiểu về UserDetails 
	Có 1 vấn đề là bây h có 2 class trùng tên User -> 1 User của hệ thống sẽ được import vào User tự tạo sẽ gọi trực tiếp tên package: domain.com.doancoso.laptopshop.User user = this.userService.fetchUserByEmail(username);
	username ở đây thì nó sẽ lấy từ Form login -> khá hiệu quả linh hoạt mỗi hệ thống sẽ có mỗi username khác nhau như sdt, email, ... đối với dự án này thì t dùng email 
	Return về giá User của Spring Security có các thông tin của User tự tạo:
	        return new User(user.getEmail(), user.getPassword(), Collections.singletonList(new 	SimpleGrantedAuthority("ROLE_USER")));
	Vì constructor của User(Spring) chỉ cần truyền vào username, password và quyền của người dùng
	Với quyền của người dùng là 1 collection<'template/generate' GrantedAuthority> trong này chỉ cần truyền vào class kế thừa từ GrantedAuthority bấm vào thì thấy nó chỉ yêu cầu dữ liệu truyền vào là 1 chuỗi String 

	Khi đã custom xong cái UserDetails service = CustomUserDetailsService -> cần nói cho Spring biết ta dùng cái Service này thay cho UserDetailsService mặc định + sử dụng hình thức hash code trong config Security:
	- Nếu dùng version 5.7 trở xuống thì cần kế thừa lại WebSecurityConfigerAdapter còn version hiện tại thì làm việc với Bean/component -> ko cần kế thừa
	- vào config Spring Security: 
    @Bean
    public UserDetailsService userDetailsService(UserService userService) {
        return new CustomUserDetailsService(userService);
    }
   	Giải thích code: đoạn code này sẽ ghi đè lại UserDetailsService mặc định của Spring Security = CustomUserDetailsService thông qua việc return lại CustomUserDetailsService (nhờ @Bean) việc truyền userService vào là vì trong CustomUserDetailsService cần userService(service tự tạo) để truy vấn xuống csdl

	Ở đây chúng ta đã nói với nó hash password và userdetailsService -> h lắp ráp chúng lại là thông báo cho spring Security ứng với việc login chúng ta pải làm như thế nào -> ghi đè lại authenticationManager để xâu chuỗi các hoạt động lại 

    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http, PasswordEncoder passwordEncoder,
            UserDetailsService userDetailsService) throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder = http
                .getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
        return authenticationManagerBuilder.build();
    }

	Giải thích code: nạp tất cả các phần chúng ta custom vào đây để gửi đến các class cần sử dụng chúng như passwordEncoder sẽ gửi cho DaoAuthentication... chứ ko pải của AuthenticationManager ... 
	
e) Hiện tại bị lỗi: khi nhập sai mật khẩu nó sẽ chạy vào vòng lặp vô tận -> Fix
- Bỏ phần code này trong config Security: vì cái Bean này nó bị mâu thuẫn với Spring Security
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http, PasswordEncoder passwordEncoder,
            UserDetailsService userDetailsService) throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder = http
                .getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
        return authenticationManagerBuilder.build();
    }

- Thay bằng: 
    @Bean
    public DaoAuthenticationProvider authenticationProvider(PasswordEncoder passwordEncoder,
            UserDetailsService userDetailsService) {
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setUserDetailsService(userDetailsService);
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder);
        daoAuthenticationProvider.setHideUserNotFoundExceptions(false);
        return daoAuthenticationProvider;
    }
	Ở đây chúng ta dùng trực tiếp DaoAuthenticationProvider để override trực tiếp lên UserDetailsService và PasswordEncoder mà DaoAuthenticationProvider này sử dụng chứ ko thông qua AuthenticationManager
	 daoAuthenticationProvider.setHideUserNotFoundExceptions(false); câu code này giúp hiển thị lỗi trong CustomUserDetailsService của chúng là là câu "User is not found" dòng 25 -> khi bạn nhập sai email + mật khẩu sai 
	-> nếu nhập đúng email mà sai mật khẩu nó mới hiện Bad Creditail -> giảm bảo mật
	Nếu để mặc định thì dù nhập đúng hay ko đúng email hoặc mật khẩu nó luôn hiển thị câu lỗi mặc định là Bad Credential -> như thế này sẽ an toàn cho hệ thống hơn 

Tiếp theo để đọc phần log trực tiếp xem hoạt động hay lỗi gì ở Spring Security ở terminal thì thêm vào trang properties:
	loggin.level.org.springframework.security=DEBUG

f) Lưu ý về lỗi Malicious String "//":
- Cần chạy lại chương trình và đọc log lỗi
- khi enable Spring Security -> phải code theo chuẩn của nó để đảm bảo an toàn 
- chỉnh lại ở các controller khi return về địa chỉ của file jsp return "admin/user/create"; ko nên return "/admin/user/create"; vì mình đang đứng ở templates -> nên dùng địa chỉ tương đối nếu ko kích hoạt Spring Security lên nó sẽ bị lỗi 
vì bên trong config WebMVCConfig mình có cấu hình mỗi lần đọc file view -> chạy vào /WEB-INF/view/
-> nếu return "/admin/user/create" -> nó sẽ chạy vào /WEB-INF/view//admin/user/create -> lỗi 


g) tiếp tục đặt và chạy dưới dạng Debug để xem cách hoạt động như so sánh password ở đâu và những trường thông tin lấy vào nó dùng ở đâu ? 
- Đặt breakpoint: 

	1 - DaoAuthenticationProvider: đặt tại dòng 53 trong hàm retrieveUser 
		function này chỉ đơn giản là return ra user mà load được tại loadUserByUsername nhưng ko biết được ai gọi đến function này (bấm chuột phải vào function này + go to declare đi đến function định nghĩa/dùng nó) là 1 abstract class AbstractUserDetailsAuthenticationProvider 
	
	2 - AbstractUserDetailsAuthenticationProvider: tại hàm authenticate() đây là hàm xử lý khi bạn nhấn submit sau khi điền thông tin đăng nhập vào form trong đó có 1 đoạn if else để check tài khoản user sai -> throws Bad credentials trên giao diện
	this.preAuthenticationChecks.check(user); để check user pre ở đây ý nghĩa là thực hiện cái này trước khi làm gì đó 
	mình bấm tiếp vào hàm check -> ra 1 interface UserDetailsChecker -> đi tới class kế thừa override nó (chuột phải vào + go to implementations) -> AbstractUserDetailsAuthenticationProvider$DefaultPreAuthenticationChecks đây là class override lại hàm check:
		ở đây nó sẽ kiểm tra các thông tin trong 1 biến UserDetails như:
			boolean isAccountNonExpired();
	   		boolean isAccountNonLocked();
		   	boolean isCredentialsNonExpired();
   			boolean isEnabled();
		để kiểm tra tình trạng của tài khoản khi mình return 1 User(Spring Security) -> nên dùng hàm khởi tạo mặc định của nó để set những biến này = true -> pass qua cái kiểm tra này nếu ko nó sẽ bị lỗi đăng nhập 
	Sau khi check tình trạng tài khoản thì nó đến check password 
	this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);
	đi đến class override lại method này cũng chính là DaoAuthenticationProvider ở class này nó override lại và tiến hành so sánh password 
	Lấy password từ trang login và nó hash code theo PasswordEncoder:
		String presentedPassword = authentication.getCredentials().toString(); 
	Lấy password từ UserDetails
		userDetails.getPassword()
	và thực hiện so sánh 
	tiếp tục mình đặt breakpoint ở dòng 38 DaoAuthenticationProvider hoặc trong cái if (nhưng pải đặt mật khẩu sai nó mới chạy vào)

	3 - SecurityContextHolderFilter: đặt breakpoint tại dòng 40 trong hàm doFilter()
	+ thêm Variable cho phần Watch: deferredContext.get() 
	Kiểm tra sau khi login thành công dữ liệu của người dùng được lưu vào đâu 



h) Chuyển đổi trang login sau khi đã hoàn thành luồng hoạt động thành trang login của dự án + một số trang ko cần login 
1 - Muốn chuyển đổi trang login -> phải biết cách thức hoạt động của nó -> inspect trang của nó xem form
- Có 3 trường thông tin: (3 name của 3 thẻ input trong form)
	username, password
	_csrf

- Sơ lược vè CSRF attack
đây là loại tấn công về an toàn thông tin: Spring sử dụng 1 cơ chế gọi là Session để lưu trữ session thì nó đang sử dụng cookies với cơ chế của cookies mỗi một lần vào website khác -> brower mặc định nó sẽ gửi kèm cookies -> để tránh trường hợp này mỗi một lần người khác vào website -> thì server sẽ generate ra 1 token lưu vào input="_csrf" này -> hacker gọi đến server của người dùng nếu ko có name=token của thẻ input="_csrf" này sẽ ko hack được token này được Java Spring tự tạo 
Csrf token: token ứng với lượt truy cập web của user. Cần token này để phòng tránh CSRF (Cross Site Request Forgery) . Hiểu một cách đơn giản, là tăng độ an toàn cho website của bạn
https://www.youtube.com/watch?v=m0EHlfTgGUU
Csrf token:
https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#csrf-integration-form
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>

-> từ nay đối với các form ngay cả đối với form login của Java Spring cần thêm 1 thẻ input chứa token này 
Cấu hình mặc định của trang login: 
https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/form.html

2 - Chỉnh sửa trang login: 
	<form action="/login" method="post">
	<input class="form-control" id="email" type="email" placeholder="name@example.com" name="username" />
	<input class="form-control" id="password" type="password" placeholder="Password" name="password" />
	Nếu để name của email = email luôn -> chúng ta cần cấu hình thêm 

	thêm: có thể bỏ vào 1 div 
	<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>

3 - cấu hình lại config để chuyển trang login 
- tìm thử trang login nó cấu hình ở đâu 
	tìm class SpringBootWebSecurityConfiguration trong này có 1 method defaultSecurityFilterChain có câu lệnh 
	http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); câu này sẽ giúp xác thực/login đối với tất cả request từ client 
	http.formLogin(withDefaults()); form login dùng default -> muốn customize form login cần phải điều chỉnh chỗ này 
	http.httpBasic(withDefaults()); // đây là dạng đăng nhập = JSON web token || form basic ko dùng trong dự án này 
- Ghi đè lại cái method SecurityFilterChain - cũng phải tạo 1 Bean vì SecurityFilterChain là 1 Bean vào config Security
	@Bean
        SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
      	  	http.authorizeHttpRequests(authorize -> authorize.anyRequest().permitAll())
        	.formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("/login/?error").permitAll());
	        return http.build();
        }
	Giải thích code: viết code từ version > 6 và dùng lamda 
	1 - http.authorizeHttpRequests(authorize -> authorize.anyRequest().permitAll())
	câu này đang đi ngược lại với Spring Security tức là bên trên mặc định mọi request đều cần đăng nhập nhưng cầu này mọi request đều ko cần đăng nhập qua .permitAll()
	
	2 - .formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("login/?error").permitAll());
	khi login phải vào url /login khi login fail redirect về login/?error và ai cũng có quyền vào trang login này 

-> Lúc nay khi chạy chương trình chúng ta có thể vào all các Url khi đổi lại: http.authorizeHttpRequests(authorize -> authorize.anyRequest().authenticate()) thì chạy vào url nó sẽ bị lỗi: localhost redirected you too many times.

	Vào xem phần log chúng ta sẽ thấy lỗi: 
	Get /login
	Get /WEB-INF/view/client/auth/login.jsp ?? tại sao có url này trong khi mình dùng url /login cho view 
	hoặc nó yêu cầu Initializing Servlet 'dispatcherServlet'
	Thực tế lỗi này chỉ có ở Spring MVC chứ nếu dùng JSON web token sẽ ko gặp 

	Lý do lỗi: vào controller 
	-> khi chúng ta vào login -> chạy tới GetMapping("/login") function chỗ này sẽ return về "client/auth/login" 
	-> với cấu hình trước đó thì nó sẽ trả về /WEB-INF/view/client/auth/login.jsp chỗ return này chúng ta đang forward lời gọi mặc định từ version 6.0 trở đi thì những lời gọi forward sẽ bị chặn -> ta cần cấu hình lại mở nó ra không thì page sẽ bị vòng lặp vô hạn nó sẽ cứ redirect 
	Tức là khi chúng ta vào trang /login thì sẽ gọi đến file view -> Spring sẽ xem đây là lời gọi chuyển tiếp 
	theo hướng dẫn:
https://stackoverflow.com/a/75223368
https://docs.spring.io/spring-security/reference/5.8/migration/servlet/authorization.html#_permit_forward_when_using_spring_mvc

	Cấu hình thêm: ở đây viết theo cú pháp lamda -> tất cả viết trong () nếu version cũ thì viết nối liên tiếp nhau .then().and()....	
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(authorize -> authorize
                .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.INCLUDE).permitAll()
                .requestMatchers("/", "/login", "/client/**", "/css/**", "/js/**", "/images/**").permitAll()
                .anyRequest().authenticated())
                .formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("/login/?error").permitAll());
        return http.build();
    }
	Giải thích code: lưu ý code sẽ được chạy từ trên xuống 
	1 - .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.INCLUDE).permitAll()
		- DispatcherType.FORWARD cho phép/mở việc khi truy cập vào 1 url -> cho phép forward tới 1 file đường dẫn tới view ví dụ url:localhost:8080/login -> vào controller -> return /WEB-INF/view/client/auth/login.jsp cho phép điều này 
		- DispatcherType.INCLUDE: nếu ta bỏ cái này thì vào bất kì url nào có truy cập đến thành phần khác như Service(gọi đến database hoặc cái gì đó khác) ngoài return 1 đường dẫn render ra view thì spring sẽ chặn lại và page đó sẽ ko load được trang và trong log nó sẽ hiện lỗi denied access 

	Mặc định trong DispatcherType Spring sẽ chặn 2 loại FORWARD và INCLUDE ngoài ra còn có REQUEST, ASYNC, ERROR kể từ Version 5.8 
	
	2 - .requestMatchers("/", "/login", "/client/**", "/css/**", "/js/**", "/images/**").permitAll()
	khai báo tất cả các đường dẫn được phép public ra ngoài ở đây ai cũng truy cập được
	
	3 - .formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("/login/?error").permitAll());
	trang đăng nhập dùng url /login lúc này nó sẽ chạy đến url trong controller của dự án khi đăng nhập sai nó redirect tới urll /login?error

Cuối cùng là hiển thị thông báo lỗi khi đăng nhập sai thêm vào dưới form của trang login
	<c:if test="${param.error != null}">
	<div class="my-2" style="color: red;">Invalid email or password.                                                	</div>                                                   
	</c:if>

i) Authorize với Spring
tham khảo: https://docs.spring.io/spring-security/reference/servlet/authorization/index.html
1 - Setup login with role
Mặc định, spring sẽ thêm tiền tố (Prefix) https://docs.spring.io/spring-security/reference/servlet/authorization/architecture.html#authz-authorities

Tạo 2 account:
user@gmail.com với role = USER
admin@gmail.com vơi role = ADMIN
=> spring sẽ lưu mặc định trong SecurityContext là ROLE_USER VÀ ROLE_ADMIN (nên ta chỉ cần khởi tạo là USER hoặc ADMIN thôi vì mặc định nó sẽ thêm tiền tố ROLE_ phía trước) nếu muốn bỏ tiền tố đó thì cần Override lại 
	@Bean
	static GrantedAuthorityDefaults grantedAuthorityDefaults() {
		return new GrantedAuthorityDefaults("MYPREFIX_");
	}

Lỗi trong file này CustomUserDetailsService.java chúng ta đang hash code cứng dù lại admin hay user thường khi đăng nhập vào đều có role là USER: Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));
=> update code thành: Collections.singletonList(new SimpleGrantedAuthority("ROLE_"user.getRole().getName())));


2 - Các hình thức kiểm tra “quyền hạn”
https://docs.spring.io/spring-security/reference/servlet/authorization/architecture.html#authz-authorities
Ở mức cơ bản, có 2 hình thức xác thực người dùng chính:

Hình thức 1: Method Security 
https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html#using-authorization-expression-fields-and-methods

- để enable cái này cần trong config Spring Security có @EnableMethodSecurity(securedEnabled = true) mặc định đã có sẵn
- sau khi enable nó lên rồi thì Spring Security sẽ cung cấp 1 số Annotation như @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter giúp kiểm tra người dùng có đăng nhập chưa, có quyền hạn gì   
- Những Annotation này chỉ áp dụng được đối với các Method ko áp dụng cho class chỉ đơn giản thêm những Annotation này trước những hàm cần tức là ví dụ method để xóa người dùng -> gắn 1 Annotation với quyền là ADMIN thì mới cho thực hiện 
- link phía trên là nơi để tham khảo các method cho dự án và một số ví dụ áp dụng 
-> đây là hình thức xác thực kĩ hơn và nó làm lớp phía sau sau khi xác thực tại Url 

Khi truy cập vào Url: localhost:8080/admin (pass 1 lớp xác thực ở đây) -> sẽ chạy vào controller (nơi định nghĩa các Mapping) và check tiến hành check quyền của user trên các method = các Annotationlúc này thì nó đã pass qa cái url (qa cái Spring Security rồi)

còn nếu viết authorize ngay tại Spring Security là ngay khi truy cập Url nó sẽ xác thực luôn trước khi nó đi sâu vào ứng dụng của chúng ta 

-> ở đây có nhiều lớp xác thực 


Hình thức 2: HTTP Request
https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html#authorizing-endpoints

- với hình thức này mỗi lần người dùng gửi 1 request đến server thì sẽ xác thực phần này trước 
- khi dùng hình thức này ta phải gắn liền với Http tức là gắn liền với đường link Url xác thực lớp ngoài ngay khi truy cập vào url nó sẽ xác thực luôn
- ở phần config trên trong khi override lại SecurityFilterChain chúng ta đã tiến hành xác thực rồi nhưng chưa có gán Role người dùng vào thôi những method những cái phương thức trong hàm này tìm hiểu ở link trên 

Ngoài ra: Domain Object Security ACLs và Authorization Events 2 phần này nâng cao 

j) Authorize By Role 
Phân tích: 
Yêu cầu 1: Với giao diện client
Không phân biệt role, ai cũng có thể truy cập trang homepage, sản phẩm và xem chi tiết sản phẩm
URL = / hoặc /product

Thêm vào /product/** vào  -> nó sẽ cho phép /product/{1}, /product/{2}, ... nó chỉ cần biết có /product/ phần phía sau bất kể là gì vẫn được 
.requestMatchers("/", "/login", "/client/**", "/css/**", "/js/**", "/images/**", "/product/**").permitAll()


Người dùng cần đăng nhập (role = USER/ADMIN) để truy cập trang giỏ hàng và đơn hàng
	URL = /cart hoặc /order

hiện tại thì đối vơi

Yêu cầu 2: với giao diện admin

(/admin) => chỉ role = ADMIN

Thêm lệnh: .requestMatchers("/admin/**").hasRole("ADMIN") hasRole ở đây nó sẽ loại bỏ đi tiền tố ROLE_ 

bây h nếu đăng nhập = tài khoản user thường -> hiển thị lỗi Forbidden 403 nghĩa là truy cập không hợp lệ/ko được phép truy cập vào trang này 



Yêu cầu 3: xử lý khi login success (optional >< previous url)
Nhược điểm: Ở đây nó sẽ mất 1 cái ưu điểm mặc định của Spring là ví dụ khi mình bấm vào 1 url mà chưa đăng nhập -> khi đăng nhập -> tự redirect tới cái url vừa bấm đó 

để làm yêu cầu 2 ta cần xem những link tài liệu bên dưới: ->

public class CustomSuccessHandler implements AuthenticationSuccessHandler {

    protected String determineTargetUrl(final Authentication authentication) {

        Map<String, String> roleTargetUrlMap = new HashMap<>();
        roleTargetUrlMap.put("USER", "/");
        roleTargetUrlMap.put("ADMIN", "/admin");

        final Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        for (final GrantedAuthority grantedAuthority : authorities) {
            String authorityName = grantedAuthority.getAuthority();
            if (roleTargetUrlMap.containsKey(authorityName)) {
                return roleTargetUrlMap.get(authorityName);
            }
        }

        throw new IllegalStateException();
    }

    protected void clearAuthenticationAttributes(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        if (session == null) {
            return;
        }
        session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);
    }

    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
            Authentication authentication) throws IOException, ServletException {
        String targetUrl = determineTargetUrl(authentication);

        if (response.isCommitted()) {
            return;
        }

        redirectStrategy.sendRedirect(request, response, targetUrl);
        clearAuthenticationAttributes(request);
    }

}

Giải thích code:

đầu tiên hàm chủ đạo để xử lý là chúng ta viết logic override lại onAuthenticationSuccess 

hàm determineTargetUrl: Phương thức này xác định URL đích (target URL) mà người dùng sẽ được chuyển hướng tới sau khi đăng nhập thành công, dựa trên quyền của họ 
	tất cả dữ liệu check nhận từ String targetUrl = determineTargetUrl(authentication);
	authentication ở đây chính là data khi đăng nhập thành công lưu vào trong Context/session
	1 - Khởi tạo bản đồ quyền-URL (roleTargetUrlMap):
		Mỗi quyền (role) được ánh xạ tới một URL đích cụ thể (VD: USER tới /, ADMIN tới /admin).
	2 - Duyệt qua danh sách quyền (GrantedAuthority) của người dùng:
		Duyệt các quyền mà người dùng hiện tại sở hữu.
		Nếu quyền của người dùng khớp với một mục trong bản đồ, trả về URL tương ứng.
	3 - Xử lý ngoại lệ:
		Nếu không có quyền nào khớp, ném ra IllegalStateException.

hàm clearAuthenticationAttributes: Xóa các thông tin liên quan đến xác thực (authentication attributes) trong phiên làm việc (session).
Kiểm tra phiên làm việc:
	1 - Nếu phiên làm việc không tồn tại (null), không thực hiện gì cả. 
		 HttpSession session = request.getSession(false);
		truyền vào tham số false để nói với spring nếu đang có 1 session thì lấy ra nếu ko có thì k lấy/làm gì cả
		nếu ko truyền vào biến false nếu ko có session nó sẽ tạo mới 	
	2 - Xóa thuộc tính lỗi xác thực:
		Xóa thuộc tính WebAttributes.AUTHENTICATION_EXCEPTION khỏi phiên làm việc. Thuộc tính này thường chứa thông tin lỗi khi xác thực không thành công (ví dụ: sai mật khẩu).

RedirectStrategy được sử dụng để thực hiện việc chuyển hướng (redirect) người dùng đến URL đích.

hàm onAuthenticationSuccess: Đây là phương thức chính được gọi khi người dùng đăng nhập thành công.
	1 - Xác định URL đích:
		Gọi determineTargetUrl(authentication) để lấy URL dựa trên quyền của người dùng.
	2 - Kiểm tra trạng thái phản hồi (response):
		Nếu phản hồi đã được cam kết (committed), không thực hiện chuyển hướng.
	3 - Chuyển hướng:
		Dùng redirectStrategy để chuyển hướng người dùng đến URL đích.
	4 - Xóa thông tin xác thực:
		Gọi clearAuthenticationAttributes(request) để xóa thông tin lỗi xác thực trong phiên làm việc.

Quy trình: myAuthenticationSuccessHandler() với hàm này t cần return về CustomSuccessHandler kế thừa lại AuthenticationSuccessHandler và ghi đè lại method onAuthenticationSuccess() viết logic ho hàm này -> User đăng nhập -> '/' - Admin đăng nhập -> '/admin'

	sau đó vào lại config tạo ra 1 Bean và ghi đè lại AuthenticationSuccessHandler return về cái class  myAuthenticationSuccessHandler 

	sau đó nạp vào 

Khi login thành công, nếu role = USER -> redirect về “/”

Nếu role = ADMIN -> redirect về /admin

Tham khảo: https://www.baeldung.com/spring-redirect-after-login

https://www.baeldung.com/spring-security-redirect-login

https://github.com/spring-projects/spring-security/blob/main/web/src/main/java/org/springframework/security/web/authentication/SimpleUrlAuthenticationSuccessHandler.java#L60

l) Chức năng Logout 
- Khi chưa đăng nhập ẩn giỏ hàng và tài khoản: có rất nhiều cách như truyền 1 biến từ Controller lên View để check
	Nhưng ở đây sẽ dùng những cái Spring cung cấp 
https://stackoverflow.com/a/21336269
<c:if test="${not empty pageContext.request.userPrincipal}">
    User <c:out value="${pageContext.request.userPrincipal.name}" />
</c:if>

- Handle Logout: https://docs.spring.io/spring-security/reference/servlet/authentication/logout.html
Nếu dùng mặc định theo Spring thì cần cung cấp 1 token cho nó là CSRF

- Tạo 1 form với action="/logout" còn lại Spring sẽ làm cho bạn trong form này phải có Token 
	<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />

m) thêm giao diện cho page Not Found khi cố truy cập vào 1 url mà user đó ko có quyền truy cập
https://www.baeldung.com/spring-security-custom-access-denied-page

n) Cơ chế Session và Remember Me 
đa số các cơ chế session mặc định ngay cả Java Spring 
	-> khi vào browser mở 1 tab đăng nhập vào 1 website sau khi đăng nhập nó sẽ lưu thông tin đăng nhập vào SESSION trong cookies 
	-> khi đóng tag đó và mở tab mới truy cập vào web thì những thông tin đăng nhập trong SESSION trong cookies vẫn còn 

	Nhưng nếu đóng trình duyệt browser thì SESSION đó sẽ mất -> khi vào lại web đó cần đăng nhập lại 
Một số ứng dụng như Facebook,tiktok, ... dù đóng browser bao lâu khi mở lại nó vẫn còn ??? 

- Để giải quyết vấn đề mất session thì Spring Security có hỗ trợ 1 cơ chế gọi là Remmember me cơ chế này sẽ tự tìm hiểu ở dự án này sẽ dùng 1 thư viên Spring Session chứ ko dùng cái có sẵn của Spring Security -> những gì Remember Me làm được thì thư viện này đều làm xịn xò hơn 

- Cơ chế hoạt động của Spring security với session và cookies:
	- Để biết được phiên đăng nhập của người dùng còn hạn hay không thì nó sử dụng 1 cookies của browser nó lưu 1 SESSIONID trong này sẽ chứa 1 key chủa người dùng 
	- vì mỗi một lần gửi dùng gửi request lên server -> sẽ kèm theo cookies server sẽ check Id trong cookies ứng với mỗi người dùng nếu có thì nó trả thông tin như bình thường nếu không có nó sẽ redirect về /login -> đó cũng là lý do mỗi lần tắt browser -> mất cookies -> quay về login
	- thông tin về key và thông tin người dùng Spring sẽ lưu ở session
		Mỗi một lần đăng nhập thành công nó sẽ tạo 1 session (chứa thông tin người dùng) ứng với 1 ID dưới dạng Key-Value với key là ID
		
	- Thực tế ở đây session nó chỉ là 1 cơ chế 1 tên gọi, chứ dự án Java cái server chúng ta đang chạy thì server này sẽ lưu thông tin trong RAM/Memory chứ ko có session nào lưu cả -> đó cũng là lý do vì sao mỗi 1 lần restart lại server thì sẽ bị văng ra khỏi phiên đăng nhập vì mỗi lần restart nó sẽ xóa đi những thông tin lưu trong bộ nhớ lưu trong RAM 

	- Để giữ một phiên đăng nhập: Cookies của người dùng gửi lên và Data người dùng đó tại server (trong Ram/Memory)
	- Tại sao ko có Cookies tên là JSESSIONID mà là SESSION vì nó được cấu hình mặc định trong CookieSerializer trong Spring Session nếu muốn nó trở thành JSESSIONID thì cần Customize lại cái này
		Cấu hình cookies: https://docs.spring.io/spring-session/reference/3.1/api.html#api-cookieserializer

	
- Cơ chế hoạt động của Session
	Bước 1: Mỗi lần vào website, Server sẽ tạo 1 cookie lưu tại client
	Bước 2: Nếu server restart, client vẫn lưu cookies => không bị mất dữ liệu
	Nếu client close browser (đóng session). Cookies sẽ mất => bị mất dữ liệu
=> tính bảo mật cao (ví dụ banking app)


1. Remember me ?
//close browser?
https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html
Về ý tưởng làm remember me mặc định của Spring Security: bên trong cái file login.jsp làm thêm 1 input là nút remember me còn lại thì spring đã tự làm rồi 

còn nếu muốn cấu hình sâu hơn thì như phiên đăng nhập đó kéo dài bao lâu thì hết hạn, ...thì thêm câu hình chỗ config http .rememberMe()

https://www.baeldung.com/spring-security-remember-me

2.Session là gì ?
https://www.baeldung.com/cs/web-sessions

Hiểu 1 cách đơn giản, Session là việc server: Lưu thông tin user vào Memory (RAM), với id để xác định user đấy là ai
	Mỗi request client gửi lên server, sẽ cần đính kèm “key”/id 
	Server sẽ dựa vào key client gửi lên, để biết client đấy là ai

3. Cơ chế Session mặc định của Spring
Được lưu tại client thông qua cookies
Được lưu tại Memory => restart lại sẽ mất thông tin

Giải pháp hay dùng: 
https://spring.io/projects/spring-session

m) Spring Session:
đối với thư viện này nó sẽ cung cấp 1 filter gọi là springSessionRepositoryFilter và Filter này sẽ ghi đè lên HttpSession	
1.Tích hợp Spring-Session
Bước 1: add dependencies
 <dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-jdbc</artifactId>
 </dependency>
không cần cài version vì kế thừa từ cha groupId

Ở đây mình cài Spring-session JDBC vì chúng ta đang sử dụng cơ sở dữ liệu quan hệ -> nên dùng JDBC

Bước 2: cấu hình với spring
//application.properties
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.security

Cấu hình vào file .properties
spring.session.store-type=jdbc // nói với spring dùng cơ sở dữ liệu quan hệ
spring.session.timeout=30m //sau bao lâu thì hết hạn session
--chỉ cần khai báo như vậy còn lại username, password, ... đã khai báo trước đó rồi 

spring.session.jdbc.initialize-schema=always//nếu chưa có Schema SPRING_SESSION trong database nó sẽ tự động tạo 
sau khi mở cmt câu lệnh này và chạy chương trình -> trong database sẽ tự tạo ra 2 table nữa là spring_session, spring_session_attributes đây là 2 nơi giúp spring lưu dữ liệu session vào 

Chỉ làm tới đây: -> từ lúc này mỗi một người dùng truy cập vào url/gửi request đến server thì trong database mặc định sẽ tạo 1 session cho người dùng đó vào database 
	spring_session: MAX_INACTIVE_INTERVAL đây là time(1800 ~ 30') 1 session tồn tại được cấu hình timeout trong properties
			PRINCIPAL_NAME nếu người dùng đã đăng nhập -> lưu username của người dùng nếu chưa nó sẽ null 
			...
	spring_session_attributes: lưu thông tin của người dùng, data nó lưu dưới dạng Blob dưới dạng này nó lưu được nhiều thông tin hơn và nếu sử dụng những thông tin này nó cần đồng bộ hóa với Memory (sau khi nó đồng bộ hóa)
	- Mỗi lần restart lại server -> restart lại phần CPU/Memory/Ram của nó sẽ xóa hết đi nhưng lần này nó đã có lưu thông tin dưới database nó sẽ load data từ database lên lại CPU/Memory khi có request -> vẫn giữ được phiên đăng nhập
	- Mỗi một phiên đăng nhập của người dùng để biết được người dùng đó là ai trong cookies nó lưu thêm 1 SESSION chứ ko phải JSESSION nếu clear cookies -> mất phiên đăng nhập 
	Cách hoạt động: 
		Mỗi một người dùng khi đăng nhập nó sẽ lưu 1 ID dưới dạng cookies với tên là SESSION và ID là value của nó sau khi	
		Sau khi restart lại server thì data trong RAM/Memory sẽ mất hết nhưng nếu người dùng vẫn còn SESSION khi gửi request sẽ kèm theo cookies -> server sẽ tìm ID/SESSION đó dưới database nếu tìm được nó sẽ nạp thông tin người dùng đó lên Ram/Memory -> server đã có lại data
		Việc so sánh SESSION trong database là nó lấy value của SESSION trong cookies đó mã hóa và so sánh với SESSION_ID trong database 

	Cơ Chế Session: 
		Trong cookies SESSION có cột Expires/Max-Age có value là session đây là cơ chế tăng tính bảo mật hoạt động giống như app ngân hàng khi out app -> cần đăng nhập lại tương tự như tắt browser -> đăng nhập lại. Đây là giá trị mặc định của Spring Session
		-> nhưng đối với dự án này cần giữ phiên đăng nhập lâu như face, tiktok, ig, ... -> giải pháp là tích hợp thêm chức năng Remember Me 
			Cơ chế hoạt động:https://docs.spring.io/spring-session/reference/3.1/spring-security.html#spring-security-rememberme	

Để tích hợp Remember Me: 
	1 - khai báo 1 Bean:
@Bean
public SpringSessionRememberMeServices rememberMeServices() {
	SpringSessionRememberMeServices rememberMeServices =
			new SpringSessionRememberMeServices();
	// optionally customize
	rememberMeServices.setAlwaysRemember(true);
	return rememberMeServices;
}

	2 - khởi tạo nó trong SecurityFilterChain filterChain
	http
		// ... additional configuration ...
		.rememberMe((rememberMe) -> rememberMe
			.rememberMeServices(rememberMeServices())
		);

Sau khi cấu hình phần này xong lúc này thì khi tắt truy cập và đăng nhập vào web -> dù tắt browser thì mở lại nó vẫn còn phiên đăng nhập
	trong database: 
		spring_session: MAX_INACTIVE_INTERVAL không còn lưu time cố định mình config trong .properties nữa mà lâu 2592000(~30 ngày) thời gian này được config mặc định được dùng trong hàm rememberMeServices bấm vào setAlwaysRemember xem code và tùy chỉnh 

	Cơ chế hoạt động: 
		cứ mỗi lần gửi request/login vào hệ thống thì Cơ chế remember me sẽ tự update MAX_INACTIVE_INTERVAL lại thành 30 ngày tính từ thời gian truy cập web (SESSION trong cookies sẽ giúp bạn không cần đăng nhập khi còn trong thời hạn session 1) Phần này thay đổi là do tích hợp cơ chế Remember Me 
		1 - Còn thời gian cấu tình trong properties nó chỉ là thời gian hoạt động của 1 session sau thời gian này nó sẽ xóa data trong Memory, còn dữ liệu trong database ko bị mật 
		2 - thay đổi thời gian Expires của 1 SESSION của người dùng trong Cookies một số khá lớn -> để hạn chế việc logout của người dùng vì cookies để định danh người dùng nó chỉ được tạo khi người dùng đăng nhập thành công nên tức là nó chỉ tạo khi đăng nhập -> những lần sau khi vào trang hay refresh nó sẽ không cập nhật được có thể customize lại được
	Đánh đổi lại sẽ giảm tính bảo mật 


2 phần cấu trình trong properties này chưa cần đụng tới
#server.servlet.session.timeout
#spring.session.jdbc.table-name=SPRING_SESSION

Bước 3: setup với Spring security

https://docs.spring.io/spring-session/reference/3.0/spring-security.html#spring-security-concurrent-sessions

Thêm trước rememberMe()
.sessionManagement((sessionManagement) -> sessionManagement
	.sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
	.invalidSessionUrl("/logout?expired")
	.maximumSessions(1)
	.maxSessionsPreventsLogin(false))

	.logout(logout->logout.deleteCookies("JSESSIONID").invalidateHttpSession(true))

Giải thích code: đơn giản phần này để tối ưu hóa 
	.sessionCreationPolicy(SessionCreationPolicy.ALWAYS) giúp tạo session khi người dùng chưa có session
	.invalidSessionUrl("/logout?expired") khi hết 1 session tự động logout 

	.maximumSessions(1)
	.maxSessionsPreventsLogin(false))
	Hai phần này giúp giới hạn tại 1 thời điểm 1 tài khoản được đăng nhập trên bao nhiêu thiết bị 
	Set giá trị là false tức là nếu A đang đăng nhập B cũng đăng nhập vào tk đó thì A sẽ bị văng ra/logout 
	Set giá trị là true tức là nếu A đang đăng nhập B cũng đăng nhập vào tk đó thì B phải đợi A hết Session mới được vào

	Phần Logout thì mỗi lần logout sẽ xóa đi Cookies JSESSIONID và báo cho server Session của  người dùng đó hết hạn 

Tới đây thì không thể mở 2 trình duyệt để đăng nhập vào dự án này với cùng 1 account, account thứ nhất sẽ bị văng ra 

i) Test Session 
1 - Lấy data user từ session or SecurityContext?
Hai cái này khi lấy thì đều phải lưu trong Memory tuy nhiên phạm vi và nội dung lưu của nó khác nhau:
	Session: 
		Kiểm soát được
	SecurityContext:
		không kiểm soát được mà phụ thuộc vào thư viên Spring Security	

Muốn lấy tên hay hình ảnh của người dùng phải đưa nó vào Session vì mặc định những thông tin lưu vào Session chính là những thông tin trong Spring Security đó chính là lý do mỗi lần restart lại server nó không bị mật phiên đăng nhập vì nó lấy thông tin từ Session nó nạp lên lại cho Spring security 

set thông tin cho Session ở đâu
	muốn nạp thông tin vào session thì cần nạp vào khi người dùng đăng nhập thành công -> chúng ta sẽ set trong hàm onAuthenticationSuccess trong config CustomServiceHandler 

Lấy thông tin ở đâu để set ?
- lấy ra email của người dùng sau khi đăng nhập cũng chính là username được lưu trong Spring Security (authentication) sẽ lấy nó ra  
- UserService để lấy ra user và load động nó lệnh:
	Tiêm UserService vào = @AutoWired chứ nếu làm thủ công theo Dependency Injection khá nhiều cái để thêm

Render thông tin đó ra view có 2 cách: 
	1 - truyền lên view thông qua controller 
		Nhược điểm: tất cả url nào cần thông tin đó đều phải truyền
	2 - render trực tiếp qua view thông qua session 
		dùng sessionScope để lấy thông tin: 
			${sessionScope.fullName}
			${sessionScope.avatar}


====Phần 15: Chapter 14 Module Cart/Order====

##1 - Sửa lại mô hình database##
Thêm 2 Model: Cart và CartDetail

cart: user_id, total_quantity 
	Mỗi user có một cart, và một cart chỉ thuộc một user (OneToOne)
Trong các Repository nên dùng findByUser ko nên dùng findByUserId mặc dù trong database của cart chứa user_id vì trong code t phải làm theo mô hình hướng đối tượng 

cart_detail: id, quantity, price, product_id, cart_id
	Mỗi cart_detail chỉ thuộc 1 cart, mỗi cart có nhiều cart_detail (ManyToOne)
	Mỗi cart_detail có nhiều product, mỗi product thuộc nhiều cart_detail (ManyToMany)

- Giao diện -> nút add to card bao bởi cái form và thêm token cho nó 
- Xử lý add product to cart trong controller và Product Service 

##2 - Chỉnh Sửa chức năng Cart - CartDetail##
	Mọi thứ làm đều cơ bản dùng những kiến thức đã học 
Bug nhỏ: 
- Ban đầu: 
	List<CartDetail> cartDetails = this.cartDetailService.fetchCartDetailsByCart(cart);
	sau đó duyệt qa loop để add product vào rồi đưa lên view 
	nhưng có bug là nếu người dùng ko có cartDetail nào -> cartDetails = null -> lỗi
- Fix:
List<CartDetail> cartDetails = this.cartDetailService.fetchCartDetailsByCart(cart) == null ? new ArrayList<CartDetail>() : this.cartDetailService.fetchCartDetailsByCart(cart);
	Lúc này nếu cartDetails nó sẽ ép kiểu về ArrayList -> đây sẽ là mảng có length = 0 -> ko loop được nhưng vẫn k lỗi

- Ban đầu:
	long numberOfCartDetails = user.getCart().getTotal_quantity();
	-> có thể người dùng chưa có cart (chưa từng click vào add to cart 1 sản phẩm) -> user.getCart() = null -> lỗi
- Fix:
	long numberOfCartDetails = user.getCart() == null ? 0 : user.getCart().getTotal_quantity();

##3 - Xử Lý tăng giải Product trong cart##

Phần này buộc phải code javascript chứ k dùng java được vì server ko biết người dùng đang làm gì ngoài giao diện
điều chỉnh lại nút tăng giảm trong resources/client/js/main.js 
	hàm // Product Quantity

##4 - Xử Lý xóa cart detail##
làm trong itemController - logic trong cart detail service

##5 - Xử Lý check out##

Khi tăng giảm cart detail thì nó chỉ xử lý ở front end nhưng khi bấm checkout -> lưu vào database 

1 - Cách xử lý Thêm form này ẩn vào nút thực hiện checkout ở /cart gửi thêm 1 cart lên view thông qa cái này t gửi thông tin những cartDetail về controller qua @modelAttribute
<form:form action="/confirm-checkout" method="post" modelAttribute="cart">
    <input type="hidden" name="${_csrf.parameterName}"
        value="${_csrf.token}" />
    <div style="display: none;">
        <c:forEach var="cartDetail" items="${cart.cartDetails}"
            varStatus="status">
            <div class="mb-3">
                <div class="form-group">
                    <label>Id:</label>
                    <form:input class="form-control" type="text"
                        value="${cartDetail.id}"
                        path="cartDetails[${status.index}].id" />
                </div>
                <div class="form-group">
                    <label>Quantity:</label>
                    <form:input class="form-control" type="text"
                        id="cartDetails${status.index}.quantity"
                        value="${cartDetail.quantity}"
                        path="cartDetails[${status.index}].quantity" />
                </div>
                <div class="form-item">
                    <label>price:</label>
                    <form:input class="form-control" type="text"
                        id="cartDetails${status.index}.price"
                        value="${cartDetail.price}"
                        path="cartDetails[${status.index}].price" />
                </div>
            </div>
        </c:forEach>
    </div>
    <button type="submit"
        class="btn border-secondary rounded-pill px-4 py-3 text-primary text-uppercase mb-4 ms-4"
        type="button">Proceed Checkout</button>
</form:form>

2 - ở Controller khi nhận dữ liệu thì tất cả thuộc tính của Cart đã mất hết chỉ có set các CartDetail vì ở view ta chỉ set thông tin cho cartDetail của cart (ko liên quan đến cart đã đưa lên view từ GET)
-> ta lấy những cartDetail này ra để xử lý ở Service (lưu ý chỉ set lại những thông tin như quantity, price của cartDetail ko liên quan đến cart và Product) xử lý ở CartDetailService
	đầu tiên lấy ra những cartDetail theo cartDetail Id được gửi qa -> sau đó set các giá trị như quantity, price theo những cartDetail được gửi đó -> save lại 

3 - Xử lý đặt hàng 
Tạo thêm 1 OrderDTO để lưu những thông tin cần thiết 
thực hiện: 
	- truyền object lên view 
	- lấy dữ liệu phía controller 
	- xử lý bên OrderService:
		tạo và set dữ liệu cho Order (chừa lại giá tiền)
		lấy cart -> lấy cartDetails -> set OrderDetails 
		set giá tiền cho Order
		remove các CartDeatils 
		update số lượng của cart 

##6 - Làm thêm Pages của Admin##

- làm view cho phần order 
- xóa order có 2 cách: 
	+ xóa OrderDetails trước rồi mới xóa Order (cách thủ công)
	+ thiết lập     
		@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
	ở Order cascade = CascadeType.ALL giúp khi xóa cha con sẽ tự xóa theo 

##7 - Hoàn thành sơ lược giao diện:##
	- Page Admin
	- Lịch sử mua hàng của khách
	- thêm product từ view detail

##8 - Tổng kết kiến thức đã học Cơ Bản:##

Các kiến thức đã học:
	- Spring Boot : cấu hình và chạy dự án Spring một cách 
nhanh chóng gồm: 
		+ quản lý file pom.xml - sử dụng maven 
		+ cấu hình file .properties 
		+ trong file LaptopShopApplication.java sử dụng @SpringBootApplication để chạy dự án (dùng các Annotation khác)

	- Spring JPA: viết query database theo ORM (object relational mapping)
		+ để tương tác với Database thông qua đối tượng chứ ko viết câu lệnh raw 

	- Cách viết code theo mô hình : Controller - Service - Repository
		+ Controller: nơi điều hướng
		+ Service: Phụ trách lấy data
		+ Repository: thực hiện hành động lấy data 	

	- Cách viết code theo mô hình Domain Driven Design : Định nghĩa domain (model)

	- Cách validate dữ liệu với package hỗ trợ sẵn của java
		+ Sử dụng trực tiếp các Annotation của java
		+ Kế thừa lại các Interface như ConstraintValidatorContext để tự customize Annotation validator 
		+ hiển thị lỗi khi invalid dùng BindingResult để đưa ra view 

	- Cách tư duy và thiết kế database, đồng thời ràng buộc mối quan hệ giữa các model (OneToOne, OneToMany, ManytoMany)

	- Cách viết code theo chuẩn DI (dependency injection)
		+ Inject vào hàm constructor
		+ dùng Annotation @Autowired		

	- Spring MVC: viết code theo mô hình MVC với view là JSP, sử dụng JSTL (Jakarta Standard Tag Library)

	- Spring Security: authentication (người dùng đã đăng nhập hay chưa ?) và authorization (người dùng có quyền làm gì) cho Spring

	- Spring Session : duy trì phiên đăng nhập của người dùng
		+ Tắt trình duyệt vẫn còn session (Remmember me)
		+ restart lại trình duyệt vẫn còn session

Ngoài ra còn có:
	- Chức năng upload file
	- Kỹ năng sinh tồn Debug xem code chạy :v

Nhược điểm của cách làm ở trên:
	- Chưa tối ưu hóa hiệu năng. Phần này sẽ được làm tiếp tục tại 2 chapter tiếp theo.

	- Reload every time 


====Phần 16: Chapter 15: Pagination Query====

##1 - Tại sao cần phân trang (Pagination) Data##

- Vấn đề tồn đọng: fetch tất cả data (paginate)
- Nếu dữ liệu nhỏ (vài chục, vài trăm rows), không vấn đề gì. Tuy nhiên, vài ngàn, vài trăm ngàn, vài triệu … sẽ là vấn đề.

Why ? lấy càng nhiều data, càng tốn nhiều băng thông (tốc độ truyền tải của mạng internet ) và thời gian chờ đợi càng lâu, làm giảm trải nghiệm của người dùng.

- Giải pháp đề ra:
Chỉ lấy số lượng data vừa đủ. Câu chuyện này tương tự :  
	+ Muốn download file nhanh -> tải file nhẹ thôi (file càng nặng, tải càng lâu, thời gian chờ đợi càng lớn)
	+ Muốn chờ đợi ít -> fetch ít data thôi nhé (và chỉ lấy data cần thiết, không dư thừa)

##2. Khái Niệm Offset/Limit##
Tài liệu: 
https://www.sqltutorial.org/sql-limit/
https://www.w3schools.com/php/php_mysql_select_limit.asp

- Limit: giới hạn số phần tử muốn lấy
- Offset: bỏ đi bao nhiêu phần tử , rồi mới lấy data

N1, N2, N3, …. N98, N99, N100 (LIMIT = 10)

PAGE 1: N1, N2, … N10 -> OFFSET = 0
PAGE 2: N11, N12, … N20 -> OFFSET = 10
PAGE 3: N21, N22,... N30 -> OFFSET = 20
…
PAGE 9: N81, N82.. N90
PAGE 10: N91, N92… N100 -> OFFSET = 90


##3 - Khái niệm Query String##
https://en.wikipedia.org/wiki/Query_string
- keyword sẽ hiển thị trên url thực tế server chỉ có 1 url dùng query string sẽ giúp cung cấp thêm thông tin cho phía server mà không cần thay đổi url 
- Quy tắc: url?key=value nếu có nhiều tham số thì dùng &

https://example.com/over/there     ?name=ferret
https://example.com/path/to/page?name=ferret&color=purple

https://example.com/path/to/search?page=1&limit=10

##4 - Design Pagination##
Tài liệu: https://getbootstrap.com/docs/5.0/components/pagination/

##5 - Spring Pagination##
Tài liệu:
https://docs.spring.io/spring-data/rest/reference/paging-and-sorting.html
https://docs.spring.io/spring-data/rest/docs/2.0.0.M1/reference/html/paging-chapter.html
- Các loại Repository hay dùng với Spring
	CRUDRepository
	JpaRepository
	PagingAndSortingRepository (là Parent của JpaRepository)
	… 

Tham khảo: https://stackoverflow.com/a/74512964

- Cách xử lý Pagination với Spring
	Kế thừa JpaRepository (kế thừa PagingAndSortingRepository)
	Sử dụng Pageable 
		là tham số truyền thêm vào trong các hàm FindAll() để phân trang 	
		FindAll() có tham số là Pageable là hàm kế thừa từ PagingAndSortingRepository và hàm này trả về kiểu dữ liệu Page chứ không phải List 

##6 -  Update Fetch Product với Pagination##
Tất cả liên quan tới Pagination import từ org.springframework.data.domain
Tham khảo: https://stackoverflow.com/questions/56240870/paging-with-spring-mvc-jpa-and-datatables

	Bước 1: Tạo Pageable Object
	Sử dụng @RequestParam (lấy dữ liệu String query + form qua attr name của tag input) để lấy tham số page từ client gửi lên
	dùng: Pageable pageable = PageRequest.of(page - 1, 2);
	hàm of:
		public static PageRequest of(int pageNumber, int pageSize) {
		      return of(pageNumber, pageSize, Sort.unsorted());
	        }	
	nó sẽ return về hàm of 3 tham số với Sort là dùng để sắp xếp 
		public static PageRequest of(int pageNumber, int pageSize, Sort sort) {
	   	      return new PageRequest(pageNumber, pageSize, sort);
   		}
	ở đây nó trả về PageRequest kế thừa AbstractPageRequest 
			AbstractPageRequest kế thừa Pageable 
	-> ép kiểu về Pageable 


	Bước 2: findAll with Pageable
	Page<Product> products = this.productService.fetchProductsPagination(pageable);
        List<Product> prds = products.getContent(); // chuyển từ Page<Product> -> List<Product>

	Bước 3: Truyền data qua view
	Lấy data với getContent

Cần tính tổng số trang
Xử lý next, prev

** Xử lý đến đây sẽ còn lỗi: có 1 lỗi, là khi bạn nhấn vào menu điều hướng bên trái, thay vì nhập trực tiếp vào url sẽ bị:  http://localhost:8080/admin/product

There was an unexpected error (type=Bad Request, status=400).
Required parameter 'page' is not present.

**Fix bug: 
Không truyền tham số page lên url
https://stackoverflow.com/questions/22373696/requestparam-in-spring-mvc-handling-optional-parameters

gán giá trị mặc định cho page = 1 (nếu không truyền page lên url)

//todo
Cập nhật quản lý user, order với pagination

##7 - Hoàn thiện Fetch Product##

Cần tính tổng số trang
Xử lý next, prev.

Logic xử lý:
Từ controller, truyền qua view: currentPage, totalPages

Sử dụng totalPages để dùng vòng lặp render ra phần pagination.
https://stackoverflow.com/a/6099110

Nếu index = currentPage -> thêm class active

Nếu currentPage = 1 => disable button “previous”.
Nếu currentPage = length của vòng lặp => disable button “next”

====Phần 17: Chapter 16 Filter Query với JPA Specifications ====

##1 -  Filter dữ liệu với Spring##

Tham khảo  query của jhipster:
https://github.com/hoidanit-be-java-spring-mvc/02-java-react-with-jhipster
https://reflectoring.io/spring-data-specifications/

- Cách Query truyền thống
	+ sử dụng Query Method : định nghĩa câu query với Spring JPA
	+ sử dụng JPA Criteria query (v2.0): https://www.mastertheboss.com/hibernate-jpa/criteria-query/hibernate-criteria-example-code/
	+ sử dụng thư viện (third-party), ví dụ: querydsl: https://github.com/querydsl/querydsl

- Đối với dự án này dùng API Specification đã hỗ trợ sẵn của Spring JPA từ version 3 trở đi 
 https://docs.spring.io/spring-data/jpa/reference/jpa/specifications.html

Ý tưởng: tương tự như việc phân trang, repository kế thừa JpaSpecificationExecutor nhờ việc kế thừa interface này sẽ cung cấp thêm các hàm findAll() với tham số truyền vào là Specification<T> -> làm sao để tạo ra biến Specification<T>

Trong interface Specification thì có rất nhiều Static function nhưng có 1 hàm bắt buộc phải ghi đè lại là: 
	toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder) 3 biến này nằm trong JPA Criteria v2.0 1 trong những cách làm Query truyền thống
	-> trả về kiểu dữ liệu Predicate 
	

Truyền specification vào hàm findAll:
List<T> findAll(Specification<T> spec);

##2 - Giới Thiệu Java Predicate##

Tài liệu: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html
https://www.geeksforgeeks.org/java-8-predicate-with-examples/

- Predicate là function trả ra boolean (true/false)
- Khi nào cần Predicate: https://stackoverflow.com/a/38278857
- Trong interface này sẽ hỗ trợ các Function này + CriteriaBuilder giúp query dữ liệu 

Sử dụng function với 1 tham số đầu vào (lưu ý đây là 1 Object), và trả ra true/false (hay được dùng với cú pháp lamda)
( arg ) - > return true/false

##3 - Giới Thiệu JPA Criteria MetaModel##

https://vladmihalcea.com/jpa-criteria-metamodel/

Trong thư mục Src:
	main: thư mục lưu code chính
	test: thư mục viết test case 
Ngoài có thư mục target 

- Cài đặt thư viện:
<!-- https://mvnrepository.com/artifact/org.hibernate.orm/hibernate-jpamodelgen -->
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-jpamodelgen</artifactId>
    <version>6.4.1.Final</version>
    <scope>provided</scope>
</dependency>

Khi cài đặt xong thư viện trong thư mục target sẽ thêm 2 Folder generated-sources và generated-test-sources 
Trong generated-sources sẽ chứa các class nằm trong domain + "_" ở cuối tên được generate tự động để giải quyết trường hợp: 
	- Khi dùng CriteriaBuilder sẽ phải truyền trường thông tin muốn kiểm tra như vậy -> hash code dữ liệu -> 
	-> dùng meta model giúp truyền động dữ liệu (là truyền động 1 tên thuộc tính chứ ko pải 1 chuỗi String thể hiện tên thuộc tính đó)

Mục đích sử dụng: hạn chế “hardcode tối đa”. Phần còn lại, thư viện lo

##4 - Create Specification##

Tài liệu:  https://docs.spring.io/spring-data/jpa/reference/jpa/specifications.html
https://reflectoring.io/spring-data-specifications/

- Specification: cách tạo câu điều kiện Where (dynamic)
- Root: đại diện table muốn truy vấn, được dùng để truy cập entity và fields của nó
- CriteriaQuery: tạo ra cấu trúc tổng quan của query, dùng để  modify the select, join, group by, order by, etc. (ít dùng)
- CriteriaBuilder: sử dụng predicates, để build ra điều kiện của câu query

Ví dụ chức năng: tìm sản phẩm theo tên (có thể ứng dụng làm tính năng search)
	Bước 1: Định nghĩa Specification
		private Specification<Product> nameLike(String name){
  			return (root, query, criteriaBuilder) 
      			-> criteriaBuilder.like(root.get(Product_.NAME), "%"+name+"%");
		}
	Tại sao nó lại return về như vậy return (root, query, criteriaBuilder) 
      			-> criteriaBuilder.like(root.get(Product_.NAME), "%"+name+"%"); có thể bấm vào bên trong interface Specification thì có một số phương thức trả về Specification<T> return về vậy -> override lại 
	(root, query, criteriaBuilder) -> cái này yêu cầu trả về 1 Predicate -> dùng CriteriaBuilder có những phương thức Static trả về Predicate 
	-> ta đã có 1 biến Specification<T> -> ở repository ta kế thừa thêm JpaSpecificationExcutor để Query có thêm phương thức findAll(Specification<T>, Pageable) 

	Bản chất khi Return như thế là nó đã trả về 1 Specification<Product> interface này chỉ có 1 function cần phải ghi đè theo cái viết lamda ta có thể viết ngắn gọn lại như vậy 

	Bước 2: Repository kế thừa JpaSpecificationExecutor để override lại một số findAll() có tham số là 1 Specification
	Bước 3: Sử dụng findAll( )
	//test = cách truyền name=abc lên url , sử dụng tính năng /products tại client

##5 - Cách Tạo Predicate với Criteria Builder##
Tài liệu:
https://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl

ở đây khi return (root, query, criteriaBuilder) -> criteriaBuilder.like(root.get(Product_.NAME), "%"+name+"%"); 
là chúng ta đang override ghi đè lại method toPredicate (khi 1 interface có đúng 1 method ko tính default || static) -> thì có thể viết như thế theo kiểu lamda

Filter dữ liệu qua criteriaBuilder 


//todo: tách riêng function search by Name để không lỗi project
//hướng dẫn cách tạo fake data để test

Bước 1: Trang bị kiến thức về SQL
Cần có kiến thức cơ bản về sử dụng điều kiện với SQL
https://www.w3schools.com/sql/

Bước 2: Xác định câu lệnh phù hợp
Các câu lệnh hỗ trợ:

https://docs.oracle.com/javaee/7/api/javax/persistence/criteria/CriteriaBuilder.html

##6 - Các yêu cầu làm Specification##
Mục đích: Tạo filter cho các tiêu chí
factory : hãng sản xuất
target : mục đích sử dụng
price: giá cả
 
Cách tư duy:
Query hãng sản xuất: dùng điều kiện in

Query mục đích sử dụng: dùng điều kiện in

Query giá cả: dùng điện kiện so sánh : equal, lessThan, greaterThan…
-> tìm kiếm theo range -> sử dụng and (sử dụng nhiều Predicate)

Lưu ý: gộp specification vào 1 class để code cho gọn 
Cụ thể:
Tham khảo: https://fptshop.com.vn/may-tinh-xach-tay

Yêu cầu 1: http://localhost:8080/products?min-price=1000
Lấy ra tất cả sản phẩm có giá cả tối thiểu là 1000 (vnd)

Yêu cầu 2: http://localhost:8080/products?max-price=100000
Lấy ra tất cả sản phẩm có giá cả tối đa  là 100000 (vnd)

Yêu cầu 3: http://localhost:8080/products?factory=APPLE
Lấy ra tất cả sản phẩm có hãng sản xuất = APPLE

Yêu cầu 4: http://localhost:8080/products?factory=APPLE,DELL
Lấy ra tất cả sản phẩm có hãng sản xuất = APPLE hoặc DELL . Truyền nhiều điều kiện, ngăn cách các giá trị bởi dấu phẩy (điều kiện IN)

Yêu cầu 5: http://localhost:8080/products?price=10-toi-15-trieu
Lấy ra tất cả sản phẩm theo range (khoảng giá).  10 triệu <= price <= 15 triệu

Yêu cầu 6: http://localhost:8080/products?price=10-toi-15-trieu,16-toi-20trieu
Lấy ra tất cả sản phẩm theo range (khoảng giá).  10 triệu <= price <= 15 triệu và
16 triệu <= price <= 20 triệu
	// case 6
	public Page<Product> fetchProductsWithSpec(Pageable page, List<String> price) {
        Specification<Product> combinedSpec = (root, query, criteriaBuilder) -> criteriaBuilder.disjunction();
		lệnh này để tạo ra 1 Specification<Product> rỗng (ko pải null) để dùng các hàm của Specification
        int count = 0;
        for (String p : price) {
            double min = 0;
            double max = 0;
            // Set the appropriate min and max based on the price range string
            switch (p) {
                case "10-toi-15-trieu":
                    min = 10000000;
                    max = 15000000;
                    count++;
                    break;
                case "15-toi-20-trieu":
                    min = 15000000;
                    max = 20000000;
                    count++;
                    break;
                case "20-toi-30-trieu":
                    min = 20000000;
                    max = 30000000;
                    count++;
                    break;
                // Add more cases as needed
            }
            if (min != 0 && max != 0) {
                Specification<Product> rangeSpec = ProductSpecs.matchMultiplePrice(min, max);
                combinedSpec = combinedSpec.or(rangeSpec); 
		// đưa lần lược các Specification<Product> hợp điều kện vào combinedSpec
            }
        }
        // Check if any price ranges were added (combinedSpec is empty)
        if (count == 0) {
            return this.productRepository.findAll(page);
        }
        return this.productRepository.findAll(combinedSpec, page);
    }

##7 - Xử lý Javascript truyền động URL Filter##

Mục tiêu:
Khi nhấn button filter, cần lấy được các tiêu chí filter, và truyền động lên URL

Khi reload page, nếu có data trên đường link, cần checkbox filter

Lưu ý:
Ví dụ: http://localhost:8080/products?page=1&price=duoi-10-trieu%2C10-15-trieu&sort=gia-tang-dan&factory=APPLE%2CACER&target=GAMING%2CTHIET-KE-DO-HOA%2CMONG-NHE

Trên url có những ký tự “%2C”, đây là dấu phẩy ae nhé. Chẳng qua là browser nó encode thành như vậy (đối với ký tự đặc biệt)

Vấn đề trên không ảnh hưởng gì tới hệ thống của chúng ta, vì đa phần các ngôn ngữ server sẽ tự động decode (chuyển cái %2C thành dấu phẩy)

Tham khảo về url encoding: https://en.wikipedia.org/wiki/Percent-encoding

##8 -  Multiple Specification##
Tài liệu:
https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/domain/Specification.html

##9 -  Add Sort
dùng pageable = PageRequest.of(page - 1, 10, Sort.by(Product_.PRICE).ascending()); để sort theo giá PageRequest là child của Pageable nên return về nó sẽ ép kiểu về Pageable 
	-> sắp xếp lúc phân trang 


====Phần 14: Chapter 17 Tổng Kết====

##1 - Roadmap Spring ##

Spring mvc là gì ?
Là cách chúng ta viết code theo mô hình Model-View-Controller, sử dụng server side rendering (tức là giao diện được tạo từ phía server)
Spring boot: cách cấu hình được dự án String
Spring MVC: cách sử dụng Service - Controller - Repository - JSP - JSTL 
Spring JPA: kết nối với database thông qua ORM 
Spring Security: authentication, authorization
Spring Session: duy trì phiên đăng nhập 


Tham khảo: https://roadmap.sh/spring-boot
File pdf road map: https://drive.google.com/file/d/19jxMycYHJaPJy3M6fqRwBWbxDyoT3sFY/view?usp=sharing
====STRING BOOT====

String Core: 
- Introduce: 
	Terminology
	Architecture: nhờ StringBoot việc chạy 1 dự án String chỉ đơn giản thông qua 1 Annotation @SpringBootApplication
	why String
- Configuration: cấu hình Security - MVC (thư mục config)
- Dependency Injection
- Spring IOC: inversion of control (Dependency Injection) 
- Spring AOP
- Spring MVC
- Annotation
- Spring Bean Scope


String MVC:
- Servlet: controller(Annotation)
- JSP Files: view
- Architecture
- components: service, model

String Data: 
- Spring Data JPA: dự án sử dụng cái này
- Spring Data MongoDB
- Spring Data JDBC
- Hibernate: 
	Transactions: giải quyết các vấn đề ngoại lệ (kiểm soát được) -> dữ liệu được toàn vẹn 
	Relationships: mới sử dụng cái này
	Entity lifecycle: 

Testing

Spring Boot: 
- Spring Boot Starters: dùng Annotation và cấu hình trong file properties 
- AutoConfiguration
- Actuators: theo dõi hệ thống 
- Embedded Server: chạy server Java như trên công 8080 ... nó đã tự động làm 

Spring Security
- Authentication: đã làm
- Authorization: đã làm
- OAuth2: đăng nhập = gg, face...
- JWT Authentication: xác thực thông qua token

Microservices:
	Spring Cloud

##2 - Sử Dụng Ajax (Extra)##

Nhấn thêm sản phẩm vào giỏ hàng: không reload lại trang (sử dụng Front end)

1. Check giao diện khi chưa đăng nhập
Khi chưa đăng nhập, không thể thêm sản phẩm vào giỏ hàng và bị đá về trang login
=> do cơ chế mặc định của Spring security (chúng ta đang authorize tất cả request)

//fix bug filter sản phẩm dưới 10 triệu (set min # 0)
//fix bug disable next/previous button (set css class)

2. Add to cart mà không reload page

Xử lý phía JavaScript: bắt sự kiện nút add to cart - xử dụng Js để update số lượng giỏ hàng 
File /client/homepage/show thêm vào <head/> thêm token _csrf vào phần header Spring có hướng dẫn ngoài việc thêm vào thẻ input trong form có thể thêm vào thẻ meta ở header để lấy token 
                <meta name="_csrf" content="${_csrf.token}" />
                <!-- default header name is X-CSRF-TOKEN -->
                <meta name="_csrf_header" content="${_csrf.headerName}" />
                <link href="https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.css"
                    rel="stylesheet">
Link href này là thư viện jquery-toast-plugin để hiển thị cái thông báo hiện bên góc pải màn hình khi bấm Add to cart 
Đóng tất cả Form của các nút Add to cart (để chuyển hướng nó qua API chứ ko cho nó chạy về Controller)
Các nút thêm data-product-id="${product.id}" để xác định đang xử lý sản phẩm nào và thêm class btnAddToCartHomepage để bắt sự kiện
Thêm Script:<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.js"></script> để sử dụng thư viện 

Sau đó sử lý sự kiện trong /client/js/main.js:
	- Kiểm tra đăng nhập qua = function isLogin()
	- sau đó lấy productId, token và header 
	- quy định 1 đường link đến server đến API
	- truyền token vào header theo cú pháp của ajax
	- truyền data lên server (truyền đến link đã quy định trước đó)
		
	- nếu thành công -> thay đổi lại số lượng của giỏ hàng thông qua ID của giỏ hàng - hiển thị thông báo thành công
	
Viết Logic cho API: 
package vn.hoidanit.laptopshop.controller.client;

import org.springframework.web.bind.annotation.RestController;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import service.com.doancoso.laptopshop.ProductService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

class CartRequest {
    private long quantity;
    private long productId;

    public long getQuantity() {
        return quantity;
    }

    public void setQuantity(long quantity) {
        this.quantity = quantity;
    }

    public long getProductId() {
        return productId;
    }

    public void setProductId(long productId) {
        this.productId = productId;
    }
}

@RestController
public class CartAPI {
    private final ProductService productService;

    public CartAPI(ProductService productService) {
        this.productService = productService;
    }

    @PostMapping("/api/add-product-to-cart")
    public ResponseEntity<Long> addProductToCart(
            @RequestBody() CartRequest cartRequest,
            HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        this.productService.addProductToCart(session, cartRequest.getProductId(), cartRequest.getQuantity());
        long sum = (long) session.getAttribute("numberOfCartDetails");
        return ResponseEntity.ok().body(sum);
    }
}

Viết lại 1 class nhận dữ liệu truyền về từ JS link POST pải giống link được quy định trong JS logic trong POST này được xử lý giống như trước chỉ thêm việc truyền cái sum lên lại view để cập nhật lại số lượng sản phẩm trong giỏ hàng giá trị này sẽ gửi lên lại ngay chỗ này success: function (response) để thực hiện cập nhật lại số lượng sản phẩm

Dùng AJAX để ko cần reload page
Cứ reload đi. Ko sao cả. Học thêm frontend và viết api sẽ giải quyết được vấn đề trên.
Tham khảo: https://github.com/kamranahmedse/jquery-toast-plugin

##3 - Phong Cách Code Dự Án Spring##
- Sử dụng DI - Dependency Injection
Tham khảo: https://odrotbohm.de/2013/11/why-field-injection-is-evil/

Có 2 cách hay dùng nhất để sử dụng DI với Spring.
	Cách 1: Field Injection với @Autowired annotation
	Cách 2: Constructor Injection 
Field injection (@Autowired)
++ less code to write
-- unsafe code
 - more complicated to test

Constructor injection:
++ safe code
 - more code to write (see the hint to Lombok)
 + easy to test


- Sử dụng interface
Tham khảo:
https://stackoverflow.com/questions/53941713/best-practice-to-organize-service-service-implementation-and-repository-in-a-spr

Viết seviceImp

- Relationship giữa các model
Tối ưu hóa hiệu năng với Fetch mode eager/lazy

Tham khảo: https://www.baeldung.com/hibernate-lazy-eager-loading

##4 - Fix Bug Generated Model##

Lỗi: không tìm thấy các file _Model trong thư mục (hoặc có nhưng vẫn lỗi)

target -> classes -> generated-sources

- Tắt ứng dụng Spring , sau đấy xóa thư mục target (đây là thư mục dịch từ code java sang .class)
- clear cache của VSCode (có thể vscode update version nên gây ra lỗi)
Chọn F1 -> Java: Clean Java Language Server Workspace"
Nhấn chuột phải vào file pom.xml , chọn “Reload Project” (chờ 1 xíu để project nó build)
- Chạy lại project. Nếu vẫn lỗi, sử dụng bước 4.
- Sử dụng phần mềm “chuyên dùng” code Java, ví dụ Spring Tool Suite.

Chạy project với Spring Tool Suite, sau đấy sử dụng VSCode.

##5 - Fix Bug Session Lưu Object##

Lý do lỗi:
Session hiện đang lưu tại database, mỗi lần người dùng đăng nhập, hoặc F5 lại website,
Spring sẽ query session này (lưu tại database) và nạp vào memory.
Session lưu vào database ở dưới dạng byte
Session dùng trong memory, đôi khi sử dụng class/object, vì vậy cần có cơ chế hỗ trợ chuyển từ class -> byte và ngược lại

fix: tất cả các đối tượng muốn lưu vào Session -> thì các class của đối tượng đó phải implements Serializable

====Phần 19: Chapter18 Tích hợp các hình thức thanh toán online====

##1.0 Tích hợp VNPay##

Áp dụng tương tự cho VietQR, MoMo, ZaloPay…

Mô Hình (kiểm thử/test)
	  (1)    (2)      (3)
Khách Hàng -> web -> VNPay -> ngân hàng
	  <-	 <-	   <-
 	  (6)    (5)       (4)

ở đây chúng ta có 1 web Thương Mại Điện Tử -> cần kết nối tới VNPay nhờ VNPay kết nối/thanh toán với ngân hàng (vì VNPay tuân thủ được các tiêu chuẩn an toàn đối với ngân hàng) từ ngân hồi sẽ phản hồi lại qua VNPay rồi tới web

? lưu thông tin như thế nào vì trên mô hình chỉ nói đến đường đi của tiền tệ (ví dụ khác đơn hàng nhưng cùng giá cả ?? -> sinh ra paymentref cho mỗi đơn hàng)

Môhình áp dụng trong khóa học

- Merchant cần tạo địa chỉ IPN (server call server) sử dụng cập nhật tình trạng thanh toán (trạng thái thanh toán) cho giao dịch. Merchant cần gửi cho VNPAY URL này.
	IPN: Instant Payment Notification
	Do IPN cần phải tạo (có https) và cần gửi cho VNPAY cấu hình, vì vậy, phần này được bỏ qua trong khóa học này.
	sẽ ko sử dụng IPN 
Mô hình áp dụng:
	Bước 1: User chọn hình thức thanh toán với VNPAY, backend cần tạo ra URL thanh toán theo tiêu chuẩn của VNPAY
	Bước 2: User tiến hành thanh toán với giao diện của VNPAY
	Bước 3: Do không có IPN, nên là sử dụng trực tiếp callback vnp_ReturnUrl
	Sau khi nhận callback, backend thay đổi trạng thái order (từ UNPAID, chuyển thành PAYMENT_FAILED/PAYMENT_SUCCEED) dựa vào tham số paymentRef

Tổng quan:
	    ---------2 Tạo url thanh toán (có paymentref + giá) redirect tới VNPAY-->
	    |									   |
	Back End <---chọn thanh toán VNP (order + paymentref) 1 --- Front End <---trả kết quả thanh toán(callback URL) 3--- VNPay <-----> Bank
	|   |							      |
	|   <------------ update order/payment status 4----------------
 5 update order status
	|
	|
	Database			(IPN)
	
thực tế nếu ở bước 4 thì VNPay sẽ cấu hình IPN để IPN update xuống database (IPN này là 1 web hook đặc biệt được viết ở pía backend sẽ an toàn hơn) nhưng ở mô hình này ko có -> thông qua url ở frontend (sẽ không an toàn) khi thanh toán thành công ta sẽ update ở controller xuống database 

làm sao để từ url ở frontend khi thanh toán thành công -> giúp backend biết được mà update payment status: 
	- khi thanh toán thành công ở trang test ở VNPay -> redirect về lại trang localhost:8080/placed-order cái này được cấu hình trong .properties hoidanit.vnpay.vnp-return-url=http://localhost:8080/placed-order và được gửi lên VNpay thực hiện qua VNPayService.java
	- ở url này thì nó sẽ kèm theo các parameters query trong số paras đó 

Bước 2 chỉ có thể tạo url thanh toán theo tiêu chuẩn của VNPay chỉ làm ở pía backend ko làm được ở pía frontend 
##1.1 Tài liệu tích hợp#
Trang chủ: https://vnpay.vn/ nơi xem thông tin chi tiết
Dành cho developer:
https://sandbox.vnpayment.vn/apis/ nơi xem thông tin về các API cho dev 
	đối với dự án này sử dụng API thanh toán PAY

Cần đăng ký tài khoản để sử dụng môi trường TEST:
https://sandbox.vnpayment.vn/devreg/ nơi đăng ký tài khoản 
Output của video này cần đặt được:
Bạn cần đăng ký thành công tài khoản của môi trường test, và có được 2 tham số sau được nhận qua email đăng ký tài khoản:
	- Terminal ID / Mã Website (vnp_TmnCode): 5NXCJC5H
	- Secret Key / Chuỗi bí mật tạo checksum (vnp_HashSecret): 920D093WUISO03CN9VH5GAC2R9TZTDE6

Sốthẻ dùng đểtest
 Ngân hàng:  NCB
 Số thẻ: 9704198526191432198
 Tên chủ thẻ: NGUYEN VAN A
 Ngày phát hành: 07/15
 Mật khẩu OTP: 123456

Tài khoản để đăng nhập vào trang quản trị của merchant (chính là email: vthanhtrongng@gmail.com/password: Thanhtrong@0510 khi đăng ký tài khoản)
https://sandbox.vnpayment.vn/merchantv2/ trang admin để kiểm tra các giao dịch 

Chỉnh sửa code:
Cấu hình trong .properties:
hoidanit.vnpay.tmn-code=5NXCJC5H
hoidanit.vnpay.hash-secret=920D093WUISO03CN9VH5GAC2R9TZTDE6
hoidanit.vnpay.vnp-url=https://sandbox.vnpayment.vn/paymentv2/vpcpay.html
hoidanit.vnpay.vnp-return-url=http://localhost:8080/placed-order


Trong domain/order.java thêm:
private String paymentRef;//lưu id thanh toán của từng sản phẩm
private String paymentStatus;//lưu các trạng thái thanh toán
private String paymentMethod; //lưu kiểu thanh toán

Trong client/checkout/show thêm
					<div class="col-12 form-group mb-3">
                                            <label>Hình thức thanh toán</label>
                                            <div class="form-check">
                                                <input class="form-check-input" type="radio" name="paymentMethod"
                                                    value="COD" id="COD" path="paymentMethod" checked>
                                                <label class="form-check-label" for="COD">
                                                    Thanh toán khi nhận hàng
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input" path="paymentMethod" type="radio"
                                                    name="paymentMethod" value="BANKING" id="BANKING">
                                                <label class="form-check-label" for="BANKING">
                                                    Thanh toán bằng ví VNPAY
                                                </label>
                                            </div>
                                            <input style="display: none;" value="${total_price}" name="totalPrice">
                                        </div>
lấy thông tin xuống controller thông qua orderDTO trong này thêm trường paymentMethod

Ở Controller:
	final String uuid = UUID.randomUUID().toString().replace("-", "");
        this.orderService.placeOrder(session, user, orderDTO, uuid);

        if (!orderDTO.getPaymentMethod().equals("COD")) {
            // redirect: VNPay
            String ip = this.vnPayService.getIpAddress(request);//tính toán ipAddress ~ tự tìm hiểu
            String vnUrl = this.vnPayService.generateVNPayURL(Double.parseDouble(totalPrice), uuid, ip);

            return "redirect:" + vnUrl;//thêm phần sau các Paras để có thể update order status

        }
Dùng uuid để generate ra paymentref và gửi qua OrderService để xử lý
	order.setPaymentMethod(orderDTO.getPaymentMethod());
        order.setPaymentStatus("PAYMENT_UNPAID");//mặc định set chưa thanh toán sau khi thanh toán thành công sẽ update
        order.setPaymentRef(orderDTO.getPaymentMethod().equals("COD") ? "UNKNOWN" : uuid); //nếu là COD thanh toán khi nhận hàng -> set UNKNOW

Tiếp tục trong controller nếu là VNPAY xử lý if để điều hướng đến trang thanh toán VNPAY xử lý trong VNPayService.java
- về code trong VNPayService.java thì được lấy ý tưởng từ https://sandbox.vnpayment.vn/apis/downloads/#code-demo-t%C3%ADch-h%E1%BB%A3p download của java file cần lưu ý trong này là ajaxServlet.java chú ý function doPost với vnp_command="pay" vì ở đây đang dùng API thanh toán = Pay trong này cần lưu ý: 
	+ định nghĩa Version 
	+ hình thức thanh toán, orderType
	+ amount(số tiền) phải nhân với 100 để khử số thập phân 
	+ bankcode 
	+ ... lấy 1 số thông tin để thêm các Paras query vào sau url trả về khi thanh toán thành công 
url ví dụ: https://sandbox.vnpayment.vn/paymentv2/vpcpay.html?vnp_Amount=1806000&vnp_Command=pay&vnp_CreateDate=20210801153333&vnp_CurrCode=VND&vnp_IpAddr=127.0.0.1&vnp_Locale=vn&vnp_OrderInfo=Thanh+toan+don+hang+%3A5&vnp_OrderType=other&vnp_ReturnUrl=https%3A%2F%2Fdomainmerchant.vn%2FReturnUrl&vnp_TmnCode=DEMOV210&vnp_TxnRef=5&vnp_Version=2.1.0&vnp_SecureHash=3e0d61a0c0534b2e36680b3f7277743e8784cc4e1d68fa7d276e79c23be7d6318d338b477910a27992f5057bb1582bd44bd82ae8009ffaf6d141219218625c42

	trong url này có vnp_SecureHash được thêm vào để đảm bảo an toàn -> chỉ có thể hash ở phía backend (chữ ký điện tử) mà frontend ko làm được 
trong function này có sử dụng 1 số tham số môi trường -> được sử dụng lại ở file config.java trong class này có khai báo một số tham số môi trường và nó định nghĩa một số function dự án cần sử dụng lại như hmacSHA512(để mã hóa) + getIpAddress(lấy địa chỉ ip) 
	có 3 cái bắt buộc pải làm ở backend:
		vnp_TmnCode: id của đối tác (người sử dụng VNPay là ai)
		vnp_TxnRef: id của order
		vnp_SecureHash: mã xác nhận + bảo mật

với dụ án này thì khai báo địa chỉ môi trường trong file properties còn lại các function cần thiết đưa hết vào VNPayService.java

Nhiệm vụ của VNPayService.generateVNPayURL để  tạo ra url bao gồm các Paras khi thanh toán thành công, tham số truyền vào ip + giá tiền + paymentref 

cuối cùng là thực hiện callback url (url trả về khi thanh toán thành công) nằm trong tham số vnp_ReturnUrl trong VNPayService.generateVNPayURL trong url trả về nó sẽ bao kèm thêm các paras có mô tả trạng thái của giao dịch -> sử dụng para vnp_ResponseCode nếu = 00 tức là thanh toán thành công -> update payment status ở controller với url placed 

ví dụ url callback:
https://localhost:8080/placed?vnp_Amount=1000000&vnp_BankCode=NCB&vnp_BankTranNo=VNP14226112&vnp_CardType=ATM&vnp_OrderInfo=Thanh+toan+don+hang+thoi+gian%3A+2023-12-07+17%3A00%3A44&vnp_PayDate=20231207170112&vnp_ResponseCode=00&vnp_TmnCode=CTTVNP01&vnp_TransactionNo=14226112&vnp_TransactionStatus=00&vnp_TxnRef=166117&vnp_SecureHash=b6dababca5e07a2d8e32fdd3cf05c29cb426c721ae18e9589f7ad0e2db4b657c6e0e5cc8e271cf745162bcb100fdf2f64520554a6f5275bc4c5b5b3e57dc4b4b

==== Phần 20 Chapter 19 ====

##1 - Tích hợp login OAuth2##

- Tài liệu tích hợp
https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html
https://spring.io/guides/tutorials/spring-boot-oauth2
https://www.baeldung.com/spring-security-5-oauth2-login

- Cài đặt thư viện
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-oauth2-client</artifactId>
	</dependency>
- Giải thích mô hình tích hợp
Cấu hình Dự án:
	Cài đặt thêm thư viện oauth2-client
Cấu hình oauth2 Provider (Google/Github):
	Mụctiêu: có được client-id và client-secret
Setup client-id và client-secret trong ứng dụng Spring:
	update user/login để tiến hành login 
Xử lý kết quả login, lưu vào Session

- Mô hình:
Backend: (1)
	cài đặt oauth2 client
	setup clientID/client Secret
	Login với Oauth2 
	tích hợp với session
OAuth2 Provider google/github: (2)
	Cấu hình app: ClientID, Client Secret
Frontend: (3)
	sử dụng session
Database

Khi User click vào login với Third Party -> từ backend pải redirect tới OAuth2 Provider 
Từ OAuth2 Provider khi đăng nhập thành công -> trả về 1 accessTokenResponse Spring lấy tokenValue của cái này để giải mã ra thông tin user về lại cho backend (đối với google sẽ có trả về lại email, nhưng github thì bảo mật và cần cấu hình thêm để nó gửi email)
Từ backend nhận thông tin user gửi từ OAuth2 Provider + thêm các thông tin của 1 user cần thiết -> lưu xún database
sau khi user đã đủ các thông tin + lưu vào session sử dụng user 1 cách bth ở frontend

- các bước cấu hình, hoạt động ngoài luồng
Cấu hình Google để lấy client ID, client Secret:
	https://console.cloud.google.com/ 
	tạo mới 1 project(chỉ cần đặt tên - bỏ qua location)
	chọn vào project đó 
	chọn phần navigation - API&Service
		chọn OAuth consent screen để khai báo mục đích sử dụng cho ứng dụng(nếu làm chính thì cần cấu hình kĩ)
			User Type: external - create
			App information: đặt tên 
			User support email: điền email nào cũng được
			Developer contact information: điền email Save and continue

			Scopes: phạm vi API muốn lấy 
				cấu hình để lấy các thông tin cá nhân của tài khoản người dùng google 
				mặc định nó sẽ trả về email, tên, avatar, ...
				(ở đây avatar của người dùng khi gửi về sẽ là 1 cái link và có thời hạn -> tự làm avatar default 
				Save and continue

			Test users: ko cần làm gì chỉ cần dùng chính xác tài khoản email 
		
			Summary: coi lại cấu hình Back to dashboard 
		
			Nếu sau này muốn làm thật pải bấm thêm PUBLISH APP 
		
		Định danh: Credentials
			Create credentials - OAuth client ID - Application Type(chọn web application + name: đặt tên)
			Authorized JavaScript Origins - ADD URI: thêm vào tên miền chạy web như http://localhost:8080
			Authorized Redirect URIs - ADD URI: thêm đường link sẽ redirect về khi login thành công lấy từ tại liệu java Spring: http://localhost:8080/login/oauth2/code/google 	
			Create 
		-> hiển thị Client ID, Client Secrect 

lấy 2 thông tin này cấu hình vào file properties: (yml || properties)
spring.security.oauth2.client.registration.google.client-id=50217281644-kl3dgv37g5vmbv99h1hcrici29553eoe.apps.googleusercontent.com
spring.security.oauth2.client.registration.google.client-secret=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

Tiến hành Chỉnh sửa code:
Frontend: client/auth/login.jsp trong form 
<div>
	<div style="text-align: center"><span>Hoặc sử dụng</span></div>
	<div class="d-flex justify-content-center align-items-center my-3" style="gap: 20px">
		<a href="/oauth2/authorization/google" title="Đăng nhập với Google">
 			<img height="40" width="40" src="/client/img/provider/default-google.png" />
		</a>
		<a href="/oauth2/authorization/github" title="Đăng nhập với Github"> 
			<img height="40" width="40" src="/client/img/provider/default-github.png" />
		</a>
	</div>
</div>
		
khi mới thiết lập endpoint /oauth2/authorization/google||github -> khi click vào thì web sẽ xoay (load) nhưng ko hoạt động vì Spring Security mặc định sẽ chặn các endpoint -> cần khai báo 2 endpoint này cho spring security 

2 đường link này được generate lấy ở tài liệu spring security:https://docs.spring.io/spring-security/reference/servlet/oauth2/login/advanced.html#oauth2login-advanced-login-page 

/oauth2/authorization/ + provider: là đường link được generate mặc định của OAuth2 

-> Cấu hình thêm Spring Security trong config/SecurityConfiguration.java trong filterChain function 
thêm 
	Cấu hình mặc định: .oauth2Login(Customizer.withDefaults()) -> khi vào trang login nó sẽ hiển thị các option provider được cấu hình trong file properties để chọn và đăng nhập
	Cấu hình theo dự án: oauth2Login(oauth2 -> oauth2.loginPage("/login")) khi đăng nhập nó sẽ vào trang login của mình và tự chọn những provider do mình cung cấp -> khi click vào provider ở trang login nó sẽ redirect tới trang login của Provider đó 
	-> khi cấu hình 1 trong 2 cái này thì khi đăng nhập dùng Third party khi chạy qa các Filter chains sẽ ko vào UsernamePasswordAuthenticationFilter mà vào OAuth2LoginAuthenticationFilter -> ProviderManager -> OpenID/OAuth2 -> loaduser 

Lúc này khi đăng nhập những thông tin lưu trong session được sử dụng ở frontend sẽ ko dùng được vì mình chưa lưu thông tin vào session cũng như thông tin người dùng vào database 

- Xử lý lưu người dùng vào database và load thông tin lên session:

Phân biệt người dùng đăng nhập = provider hay đăng kí tài khoản thông thường: thêm vào domain/user.java
	private String provider; 
	sử dụng 1 hook của API để trong trường hợp ko gán giá trị cho provider sẽ gán giá trị mặc định 
    		@PrePersist
    		public void prePersist() {
        		if (this.provider == null) {
            			this.provider = "LOCAL";
        		}
    		}


làm sao để giữ được session cho người dùng đăng nhập = provider 


- Debug Luồng Hoạt Động của OAuth và Spring Security (Extra)
Tài liệu: https://docs.spring.io/spring-security/reference/servlet/oauth2/login/advanced.html
Mụcđích: hiểu “sâu hơn” về những thứ đã làm “mặc định” của Spring Security.

+ Xử lý mặc định khi chạy app Đặt breakpoint và restart ứng dụng.
	Cấu hình trong config ban đầu .oauth2Login(oauth2 -> oauth2.loginPage("/login") đối với oauth2Login nó nằm trong class HttpSecurity.class tham số truyền vào của function này là OAuth2LoginConfigurer() ~ ở đây ta sẽ truyền vào 1 config nào đó

	Ctrl + T
	HttpSecurity.class-> oauth2Login()

	OAuth2ClientAutoConfiguration 	// đây là config mà ta cần truyền vào trong class này ta chú ý đến class OAuth2ClientRegistrationRepositoryConfiguration

	OAuth2ClientRegistrationRepositoryConfiguration (đặt breakpoint) trong class này có function return ra InMemory... đây là nơi mặc định ứng dụng chạy vào dùng để lưu thông tin vào Memory/RAM của máy tính. Trong function này có OAuth2ClientPropertiesMapper

	OAuth2ClientPropertiesMapper.class là nơi map các thuộc tính lại những thuộc tính này được nạp lên từ file properties + một data khác mà nó nạp lên nữa là từ CommonOAuth2Provider.class

	CommonOAuth2Provider.class trong này sẽ set một số thông tin của các provider mặc định (hiện tại thì hỗ trợ github, facebook, google, okta, ... như scope(phạm vi lấy), một số url mặc định, ...

	nhờ có việc cấu hình ở /config .oauth2Login(oauth2 -> oauth2.loginPage("/login") -> Spring đã tự động thêm các cấu hình mặc định khác rồi
 => lưu cấu hình mặc định vào memory (restart là mất)

+ Xử lý quá trình login
Lưu ý 1: trước khi test login, cần clear cookies, đồng thời restart server để clear session
Lưu ý 2: khi học về Spring Security login với username và password. 
Quy tắc: chạy Filter đầu tiên
Luồng đã được làm sẵn:
Sau khi Provider login thành công, sẽ trả về thông tin xác thực người dùng thông qua quá trình sau những filter pải chạy qa:

OAuth2LoginAuthenticationFilter -> attemptAuthentication (đặt breakpoint tại function này) chạy vào khi click vào đăng nhập = provider 
	dòng 75: OAuth2LoginAuthenticationToken authenticationResult = this.getAuthenticationManager() liên quan tới Manager để biết được Manager nào xử lý thì bấm vào Step into (giúp chạy vào hàm getAuthenticationManager, step over sẽ chạy line by line) mở ra 1 Abstract... ... -> để quản lý loại Provider nào được sử dụng -> check class ProviderManager nơi chạy vòng lặp để chọn ra Provider thích hợp cho việc Login của người dùng 

	đặt BreakPoint trong vòng lặp dòng 182 result = provider.authenticate(authentication) bấm continue thì Provider đầu tiên chạy vào là OAuth2LoginAuthenticationProvider (tức là provider = OAuth2LoginAuthenticationProvider) bấm step into để vào function authenticate của provider đó làm gì
	khi vào function authenticate thì có: 
	if (loginAuthenticationToken.getAuthorizationExchange().getAuthorizationRequest().getScopes().contains("openid")) {
         return null;
	}
	thì mặc định scope khi ta login = google thì có có openid được cấu hình mặc định ở CommonOAuth2Provider.class -> vào đây nó sẽ trả về null -> spring sẽ bỏ qua và ko sử dụng Provider này để tiến hành đăng nhập mà sử dụng ...
	Để override ghi đè lại scope để cho spring sử dụng provider này đăng nhập (vì khi dùng với github mặc định ko có openid nên sẽ dùng provider này -> goole ta nên cấu hình dùng provider này luôn) thì cấu hình thêm trong file properties 
	spring.security.oauth2.client.registration.google.scope=email,profile chỉ lấy email,profile thôi bỏ openid đi

	Nếu ko cấu hình lại để mặc định nó sẽ chạy đến Provider tiếp theo (cái sẽ dùng mặc định nếu ko cấu hình) là OidcAuthorizationCodeAuthenticationProvider trong hàm authenticate có accessTokenResponse (cái được trả về khi đăng nhập thành công Spring sẽ lấy cái token này để giải mã ra được thông tin của người dùng dùng postman để check https://www.googleapis.com/oauth2/v3/userinfo endpoint mặc định trong class CommonOAuth2Provider cung cấp thêm accessTokenResponse.accessToken.tokenValue để lấy thông tin - lưu ý nhớ common lại phần override scope để mở openid lên nó chạy vào provider OidcAuthorizationCodeAuthenticationProvider mới test được) 
	dòng 75 OidcUser oidcUser = (OidcUser)this.userService.loadUser(new OidcUserRequest(clientRegistration, accessTokenResponse.getAccessToken(), idToken, additionalParameters)); đây là nơi spring gọi API để từ Token chuyển sang thành thông tin của người dùng function loadUser() là từ OidcUservice.class 
	đầu ra của function Authenticate của OidcAuthorizationCodeAuthenticationProvider Authentication chứa các thông tin của người dùng nằm trong Authentication.authorizationExchange.principal.attribute

	cuối cùng khi đã có Authentication nó vẫn sẽ lưu vào SecurityContextHolderFilter như bth 

SecurityContextHolderFilter
	Watch variable: deferredContext.get()
	thông tin lưu trong này sẽ có 1 số thông tin như email, name sẽ sử dụng như user bình thường nhưng phần quyền (Role: admin, user) sẽ ko dùng được -> sẽ hash code cứng thêm các thông tin này sau 

đó những filter đầu, cuối sẽ chạy qa bỏ qa những Filter ở giữa qá trình 


- cấu hình chuyển từ Oidc -> OAth

Login OAuth2
Tài liệu: https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html#oauth2login-sample-initial-setup

 Ctrl + T

Đối với khi dùng OidcAuthorizationCodeAuthenticationProvider:
	trong này có accessTokenResponse(chỉ có giá trị trong 1 giờ) thông thường khi có token sẽ gọi API để lấy info nhưng đối với dạng Provider này thì sẽ ko có gọi API mà lấy thông tin nay tại idToken dòng 73 (step into) vào trong hàm createOidcToken -> nó sẽ giải mã token ở đây để lấy info tại pía backend hàm này sẽ return về idToken (thông tin user nằm trong idToken.claims) nó sẽ giải mã token để lấy thông tin tại đây ko cần gọi API 
	Tiếp tục dòng 75 oidcUser (nơi dùng loadUser) hàm loadUser này từ OidcUserService.java trong này có một đoạn dùng để kiểm tra load user if (this.shouldRetrieveUserInfo(userRequest)) ở đây khi mình ko quy định pần Scope thì nó mới load user lên (tức là nếu ko override lại scope để mặc định cho dùng provider này thì pần này sẽ được chạy) 

-> OpenId và OAuth2 là 2 tiêu chuẩn 	

Oauth2LoginAuthenticationProvider
Sử dụng OAuth2 hay OpenID Connect (oidc) ?
https://security.stackexchange.com/questions/44611/difference-between-oauth-openid-and-openid-connect-in-very-simple-term/44614#44614

- Update code: 
	Ép chuyển từ sử dụng OpenId -> OAuth2(overide lại scope = cấu hình lại file properties)
		spring.security.oauth2.client.registration.google.scope=email,profile
	-> khi chuyển qua Provider này tương tự như dùng Postman nó sẽ gọi API để lấy thông tin quy trình: đầu tiên chạy vào hàm authenticate của OAuth2LoginAuthenticationProvider.class 
	khi chạy đến dòng 50 loadUser: OAuth2User oauth2User = this.userService.loadUser(new OAuth2UserRequest(loginAuthenticationToken.getClientRegistration(), accessToken, additionalParameters)); 
	hàm loadUser của DefaultOAuth2UserService.class khi chạy đến dòng 54 bắt đầu gọi API: RequestEntity<?> request = (RequestEntity)this.requestEntityConverter.convert(userRequest);
	hàm convert của OAuth2UserRequestEntityConverter.class gọi API ở đây giống như dùng Postman thiết lập URI + Token -> lấy được thông tin của user với URI để lấy info mặc định của Spring là https://www.googleapis.com/oauth2/v3/userinfo được cấu hình trong CommonOAuth2Provider và AccessToken 

	- Vấn đề xảy ra là khi lấy được thông tin và lưu vào ContextHolder thì những thông tin này ko giống định dạng của 1 user bình thường -> cần customize lại cách lưu thông tin người dùng 
	tài liệu: https://docs.spring.io/spring-security/reference/servlet/oauth2/login/advanced.html
	-> cần ghi đè lại interface DefaultOAuth2UserService = service/userinfo/CustomOAuth2UserService.java rồi add nó vào Security để đè lên cái chạy mặc định 
		Cần UserService để query xún database để kiểm tra có email này chưa (ko có thì tạo tài khoản mới, nếu có rồi thì lấy ra ROLE của user đó)
		interface này có 1 hàm duy nhất là loadUser hàm này sẽ định nghĩa cách thức nạp thông tin vào Security ContextHolder 
			đầu tiên gọi super để Security nạp thông tin user sau khi có user: oAuth2User -> lấy ra attributes  oAuth2User.getAttributes(); (chứa các thông tin cần thiết của user như tài khoản gg, còn oAuth2User.authoritis -> chứa các quyền mặc định của spring cấu hình phần này ko dùng đc)
			registrationId giúp nhận biết được dùng provider nào để đăng nhập (google hay github) để biết lưu thông tin vào database cho đúng 

			Phần xử lý lỗi nếu email == null: ở đây là th khi đn = github -> nó sẽ ko trả về thông tin của email -> hiển thị lỗi. hiện tại cũng ko đn = git hub đc cần cấu hình thêm throws ra excpt và cho hiển thị lên frontend qa jsp
			tiếp theo nếu khi đăng nhập đã gửi về email -> thì kiểm tra email này đã có trong database chưa || đã đn = email này lần nào chưa. nếu chưa có thì tạo tk với một số tham số cố định và lưu vào database 
			cuối cùng là return về 1 DefaultOAuth2User set Role cho nó ở đây giống như lúc cấu hình đn bình thường với Spring Security service/CustomUserDetailsService.java lúc return về User tham số: role, attributes, string là key giúp pân biệt các user với nhau 

cuối cùng là nạp vào Security và customize lại .userInfoEndpoint
	


- Oauth2 là 1 tiêu chuẩn để kết nối giữa các hệ thống khác nhau 
	Trong dự án này sẽ sử dụng OAuth2 Log in + OAuth2 Client 
	OAuth2 Resource Server sẽ làm ở Restful API 
	chỉ cho accessToken và pải gọi lại API của nó để lấy thêm thông tin 
	(authentication: chỉ xác định quá trình đăng nhập)
	dùng accessToken -> gọi API của nó để giải mã token -> lấy thông tin 

- OpenId: thì sẽ xác định chính xác lun bạn là ai - thông qua việc cung cấp lại token -> giải mã được token này -> lấy ra thông tin(authorize: xác định rõ bạn là ai)
	giải mã token -> lấy thông tin

- Về độ an toàn thì tùy theo đánh giá của các ThirdParty: 
	đối với google thì cung cấp cả 2 là: openID(*), Oauth2
	đối với github chỉ cung cấp: Oauth2


- Xử lý đăng nhập với github: 	
Tạo Github OAuth App https://github.com/settings/developers
	Authorized JavaScript origins: http://localhost:8080
	Authorized redirect URIs: http://localhost:8080/login/oauth2/code/github
Cấu hình Java Spring
	//application.properties
	spring.security.oauth2.client.registration.github.client-id=<your client id>
	spring.security.oauth2.client.registration.github.client-secret=<your client secret>

Lưu ý: có 2 vấn đề lớn (bugs) cần phải fix, mình nêu ra để các bạn biết và TỰ FIX (coi như là bài tập giao thêm)

Bug 1: Nếu account github để tại chế độ private và không public email sẽ không lấy được thông tin trường email.
Để fix thì có 2 cách:--
	Cách 1 (dễ nhất): là check điều kiện email = null, ném ra exception luôn (tức là không cho sử dụng tài khoản đấy để login)
	Cách 2: khi làm dự án của các bạn, cần thiết kế table users khác đi (như mình phân tích trong video). Như vậy, khi lưu user mà không truyền email/password sẽ không bị lỗi

Bug 2: sử dụng 1email cho cả Google và Github
Ví dụ: bạn đăng nhập thành công với Google, sau đấy lại đăng nhập với Github, và cả 2 tài khoản trên cùng sử dụng chung email, sẽ gặp tình trạng là tên hiển thị (fullName) và avatar là của tài khoản trước đó.
Để fix thì có 2 cách--
	Cách 1 (dễ nhất) : là khi login, cần check xem email với “provider” GITHUB/GOOGLE đãtồn tại chưa. Nếu tồn tại => ném ra exception và dừng quá trình đăng nhập
	Cách 2: tương tự như bug 1, cần design lại table users
 
Gợi ý cách fix 2 bug ở trên, bằng cách sử dụng exception:

Ý tưởng: file CustomOAuth2UserService ném ra OAuth2AuthenticationException
	=> cần tạo ra OAuth2AuthenticationException
Bước 1: cần némra exception tại file CustomOAuth2UserService.java
Ví dụ bug 1:
// handle exception
if (email == null) {
	OAuth2Error error = new OAuth2Error("invalid_request", "Can't get email address. Maybe login with private email (Github)", null);
throw new OAuth2AuthenticationException(error);
}

Ví dụ về bug 2:
 if (!user.getProvider().equalsIgnoreCase(registrationId)) {
	 OAuth2Error error = new OAuth2Error("invalid_request", "Can't use this email address. Account already exist : " + email, null);
 throw new OAuth2AuthenticationException(error);
 }

Bước 2: Xử lý exception, tạo thêm 1 cái handler cho trường hợp failed Làm tương tự CustomSuccessHandler.java, tuy nhiên cần kế thừa AuthenticationFailureHandler, tức là giải quyết cho case failure.
Tương tự việc xử lý successHandler, tạo thêm failureHandler, ví dụ như bên dưới:
 @Override
 public void onAuthenticationFailure(
	HttpServletRequest request, HttpServletResponse response,
	AuthenticationException exception) throws IOException, ServletException {
	response.sendRedirect("/login?error=" + exception.getMessage());
 }

=> mụctiêu ở đây, là ném chi tiết lỗi của exception lên đường link url của /login

Bước 3: khai báo handler vào security
Sau khi đã có failureHandler, khai báo vào security: (làm tương tự cái success)
.oauth2Login(oauth2-> oauth2.loginPage("/login")
.successHandler(customSuccessHandler())
.failureHandler(customFailureHandler())

Bước 4: hiển thị exception ra view Sửa file login.jsp
<c:if test="${param.error != null}">
	<div class="my-2" style="color: red;">
	${param.error == "" ? "Invalid email/password" : param.error}
	</div>
</c:if>
 //Nếu có lỗi, hiển thị chi tiết lỗi, còn không , hiển thị invalid email/password

DONE


	























		

	








	



	

	

	








	
			



		
			
	

	
	